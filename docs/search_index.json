[
["index.html", "R fundamentals About this book", " R fundamentals Locke Data About this book Welcome to the first book in Stephanie Locke of Locke Data’s series on R and data science! This first book introduces R itself, helps you get the most out of the RStudio programming environment, and teaches the basics of getting things done in R. Already know the basics of R? You can skip right onto the next book in this series [BOOK NAME/LINK here] From StaRt to Finish by Stephanie Locke is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],
["what-you-need-to-already-know.html", "What you need to already know", " What you need to already know This book assumes no prior knowledge of programming, or R. A basic knowledge of mathematics will come in handy, but isn’t required. You will need a good understanding of the use of calculators or Excel for mathematics. You will need the required access to be able to install (or get installed) R, RStudio, and, if on Windows, RTools. You can code online at r-fiddle.org but this might be unreliable. The instructions for installation can be found in the apendix of this book [link to apendix here] "],
["steph-locke.html", "Steph Locke", " Steph Locke I am a Microsoft Data Platform MVP with over a decade of business intelligence and data science experience. Having worked in a variety of industries (including finance, utilities, insurance, and cyber-security,) I’ve tackled a wide range of business challenges with data. I was awarded the MVP Data Platform award from Microsoft, as a result of organising training and sharing my knowledge with the technical community. I have a broad background in the Microsoft Data Platform and Azure, but I’m equally conversant with open source tools; from databases like MySQL and PostgreSQL, to analytical languages like R and Python. "],
["locke-data.html", "Locke Data", " Locke Data I founded Locke Data, an education focused consultancy, to help people get the most out of their data. Locke Data aims to help organisations gain the necessary skills and experience needed to build a successful data science capability, while supporting them on their journey to better data science. Find out more about Locke Data at itsalocke.com. "],
["conventions.html", "Conventions", " Conventions Throughout this book various conventions will be used. In terms of basic formatting: This is standard text. This is code or a symbol This is a Keyboard Key! This is a book about coding, so expect code blocks. Code blocks will typically look like this: &quot;this is a code block&quot; ## [1] &quot;this is a code block&quot; There will also be callouts throughout the book. Some are for information, some expect you to do things. This is a tip relating to what I’ve just said. This is kind of like a tip but is for those break-the-glass, moments where things have gone very very wrong and you need to escape. This is something I recommend you do as you’re reading. This let’s you know that something I mention briefly will be followed up on later, whether in this book or a later one. If this is still here, someone at Locke Data needs to do something! "],
["about-r.html", "1 About R 1.1 Key points to know about R", " 1 About R R is an open source language released in 2001 that’s ideal for data wrangling and data science. R has a long lineage - it was written to re-implement the language S. S was a commerical language written in the mid-1970s to enable statistical and graphical processing. Indeed much code written in S can still run today, a phenomenal feat! If you ever look at how R and wonder “Why on Earth does it work like that?”, the usual answer is “Because S”.1 The previous paragraph might lead you to ponder why R is in use today and why the popularity is growing. R is a vibrant ecosystem that enables people to extend, enhance, and replace any part of it. There are many paradigms in R to facilitate object-oriented programming, functional programming, and more. If you can write something in R, C++, FORTRAN2, Python, or JavaScript you can extend R. There are currently more than eleven thousand extensions (refered to as packages) to R in the core ecosystem (CRAN) and two and a half thousand packages in the genomics ecosystem (BioConductor). We’re also seeing emerging ecosystems and paradigms within CRAN. The tidyverse is one such ecosystem, focussed primarily on analysing tabular data, and it will be used in future works extensively. 1.1 Key points to know about R R works in-memory which means that the processing is fast but the amount of data you can process is limited to how much RAM your data takes up and how much your computations will require. R is not multi-threaded by default. R works on a single CPU core and parallelisation requires additional packages and often additional coding. R is quirky! R works a bit like lots of languages which makes it easy to pick up in some respects, but because of the S compatability it’s actually pretty darn old and a result, really odd in places. Coding R will give you the typical gotcha’s and add another, case sensitivity. R is (un)fortunately a language where “Red” and “red” are different and this also extends to variable and function names. As a consequence, the most common errors you’ll find when writing code in R are: Mis-placed or missing commas Mis-placed or missing brackets Incorrect case used when typing With so many packages available to extend R with, the answer to “how do I write this?” is usually “there’s a package for that”. We’ll look at finding packages later in this book. If you’d like to find out about the assignment operators’ history (&lt;- and -&gt;) and many of the other quirks of R, the article Rbitrary is fantastic and highly irreverent reading.↩ Yes, it still exists and yes, R still relies on it for some key algorithms↩ "],
["why-use-r.html", "2 Why use R? 2.1 Data wrangling 2.2 Data science 2.3 Data visualisation", " 2 Why use R? R as a programming language is brilliant at it’s core competencies – statistics and data visualisation. It’s also a great “glue” language, by which I mean that you can use it perform computations in many different languages and combine the results smoothly. As a result, R enables you to be an effective data wrangler, data scientist, and/or data visualisation practitioner. I wanted to include some code snippets here that exemplify how little is required to do things in R that in other languages or tools used to take me a substantial amount of time. These are illustrative only. Don’t worry if they don’t make much sense. Writing code like these examples will be covered in later books. 2.1 Data wrangling A common issue I’ve had in the past is data from multiple sources that should usually conform to a template but don’t. You end up with a whole stack of files that don’t quite match the template and as a result getting all this data read, combined, and then output somewhere else is often an incredibly difficult task. This snippet of R code performs the following steps: Make functionality from the tidyverse available Identify files needing to be read and combined Read each file individually, whilst applying a column type enforcement Combine the results Combining the results involves matching the columns by name. It will create new columns when it finds additional columns in some of the data and fill in the data. When columns are missing from a dataset it will put NAs in the column. library(tidyverse) # Change &#39;../data&#39; to where your files are. Remove the col_types bit if # your columns are fairly type safe. allmydata &lt;- list.files(&quot;../data&quot;, full.names = TRUE) %&gt;% map_df(read_csv, col_types = cols(&quot;c&quot;)) %&gt;% bind_rows() nrow(allmydata) ## [1] 105 2.2 Data science An aspect of building models and operationalising them that I’ve always found a bit painful is mapping the pre-processing stages to an operational scenario i.e. how do I apply my pre-processing steps to new data in order to be able to make a prediction? If I want to scale numeric variables, I need to keep some sort of record of the mean and standard deviation in the case of a z-score or the minimum and maximum values if I wanted to do a minmax score. Then I’d have to write something to apply these values to new data in an operational setting, or I’d have to transform my model’s formula to apply the scales on the fly. If I wanted to take it a step further and perform a Principal Component Analysis (PCA) to reduce the amount of features I was working with, I’d have no easy way to do that with the outputs of the R PCA function (princomp()). If I use these principal components in my model, how then to get these for my test data or in production? This snippet of R code performs the following steps: Make functionality from caret available Split my data into training and test samples with the outcome column seperate Build a linear regression model on data scaled using z-scores and turned into principal components Apply the transformations and linear model to get predictions for my test data Instead of using some of the out of the box methods and writing a really long-winded set of code, I can use functionality from the package caret to add a pre-process step to my model develoment. It will then keep these pre-process steps as part of the model and whenever I use the model to make predictions it will first process the data based on the parameters and transformations used on the training data. library(caret) training_data &lt;- mtcars[1:20, -2] training_outcome &lt;- mtcars[1:20, 2] test_data &lt;- mtcars[21:32, -2] test_outcome &lt;- mtcars[21:32, 2] model &lt;- train(training_data, training_outcome, method = &quot;lm&quot;, preProcess = c(&quot;scale&quot;, &quot;center&quot;, &quot;pca&quot;)) predictions &lt;- predict(model, test_data) 2.3 Data visualisation Data visualisation is an area where R makes it especially difficult to choose just a single example. Instead of showing the many fancy or interactive visualisations you can do in R, I’m instead going to show a part of the workflow. Often times, I need to make a chart and then make that chart for a lot of different datasets. These could be datasets for different customers, samples, or time slices. I can make a chart in R using the package ggplot2 to build a chart of all data. library(ggplot2) library(datasauRus) myPlot &lt;- ggplot(datasaurus_dozen, aes(x, y)) + geom_point() If you want to make a small multiples chart, where the charts are produced in a group, you can use the notion of facetting to make many small charts together. myPlot + facet_wrap(~dataset) If you wanted to produce and save a chart per dataset you can provide updated data to a chart. myPlot %+% simpsons_paradox "],
["using-rstudio.html", "3 Using RStudio 3.1 The console 3.2 Scripts 3.3 Code completion 3.4 Projects", " 3 Using RStudio RStudio is a coding interface to R that makes it easier for you to be productive.3 I’m devoting substantial amounts of this book to your working environment as you can use it to make learning and coding R much easier by taking the time to understand it. The interface will be split up into a top menu and then four panes, although only three may be visible when you first start RStudio. Clean RStudio image, no arrows If you don’t already have it, you should install R and RStudio. If you’re on Windows, it’s also great if you can install Rtools. This gives you the tools to install packages from GitHub later on down the line. 3.1 The console Make a small gif of using the console The (bottom) left hand section is the console. This is where you can execute R code directly. To use the console you type some code alongside the &gt; and hit Enter for the code to be executed. The result will then appear underneath your line of code. Errors, warnings, and messages will also appear in the console. We’ll discuss what these are later in the book Use the console to add two numbers together. If the code you entered wasn’t a complete statement e.g. 1 + 2 +, when you hit Enter, the &gt; will change to a + indicating the code you’re writing will be appended to the line before it. If you want to clean your console and start afresh, hit Ctrl + L to remove whatever has been executed in the console this session. You can use your up and down arrow keys to navigate through previous code you’ve written and executed. If you commit one of the most common coding errors (incorrect amounts or places of brackets and commas) you might end up with an incomplete line and basically lock your console into having thte + symbol at the beginning of each line. If you find yourself stuck with commands just writing and writing and never executing, hit the Esc key to cancel the code and get back to the standard cursor. 3.2 Scripts Create gif of adding a file RStudio allows you to create and work with files containing code. These files give you a way to store and manage your code. The most common file types you might use are R files (.R) and rmarkdown files (.Rmd). rmarkdown files are for generating documents with text and R code interleaved (like this book!) will be covered in a book in future. If you want to get going, checkout the rmarkdown site. You can create one of these files by going to File &gt; New &gt; R Script, the New File button, or with the hotkey combo4 of Ctrl + Shift + N. In an R script you can type code and execute it by hitting Ctrl + Enter5, or selecting the code to run and hitting the Run button. You can execute all the code in a script by hitting Ctrl + Shift + Enter or hitting the Source button. Open a new R script. Write 10*5 in it and execute the code. 3.3 Code completion Create a gif with code completion Whilst writing scripts or typing in our console, we can get help and be more productive by using code completion. Code completion will pick up from what we’ve typed so far and provide a navigable list of suggestions. As we navigate through the list, it’ll provide help text where possible and then it will complete the code we were typing. You access the code completion by hitting Tab whilst typing. Once it’s up you can keep typing to refine the list. Your arrow keys allow you to navigate the list. Hit Esc to back out of the completion capability. Hit Tab to accept whatever value in the list is currently highlighted. On a new line of your script, type a and activate your code completion. Browse the list then cancel out of the list. Overwrite the a with an A and go back into the code completion. Do youu get the same list? What’s different and why? 3.4 Projects So far you’ve seen R as a scratchpad (via the console) and for making an isolated script, but a lot of the time we have to be put data, multiple scripts, documentation and more into a project. An RStudio project is a folder with an extra file. This file can be used to open RStudio, with everything laid out like it was before you closed the project. It can store preferences to allow projects to vary from the way you normally do things.6 At this point in your R coding career, keeping everything where you left off is great. Later on, and especially if you work in anything where reproducibility is valued, you can go to Tools &gt; Project Options … and set the .Rdata fields to “no” so that nothing loads up into memory when you load the project. You can, and should, create a new R project when embarking on a new area of work. To create a project go to File &gt; New Project. Create a gif of making a project This will popup a dialogue that gives you the option to create a brand new project directory, create one from some existing directory you might already have, and creating one with the content of a project in your source control system. Most commonly, you’ll want to create a new directory project. Once selected it’ll then give you the option to create an empty project, a shiny project, or an R package. You’ll normally select the empty projects. Once an option is selected, provide a name and where the project should go. Working with source control, shiny, and creating R packages are all in later books. You can navigate to projects using the project option in the top right corner or in the File section. Create a new project to store the answers to exercises and any code you try out during this book. You don’t have to save the script you were working on before this (unless you want to!) If coding interfaces were game modes, RStudio is Easy mode, Visual Studio is Normal, R-GUI is Hard, vim is Insane, and Emacs is Legacy.↩ I’m a big fan of hotkeys!↩ This hotkey is really nifty as it’ll find the start and end of a block of code and send it all to the console to be executed.↩ Like converting tabs to spaces and the number of spaces characters it should replace with.↩ "],
["useful-resources.html", "4 Useful resources 4.1 The built-in help 4.2 Online 4.3 In-person", " 4 Useful resources Our coding environment RStudio is a great help to us. The code completion makes it easy to find things kind of related to what you’re typing but sometimes you need to do a bit more digging or read a bit more than the snippet of help in the code completion window. 4.1 The built-in help R has pretty great built-in help. You might understand some of it but there’s usually lots of it and most help files give you examples to run. The help files are accessible in the bottom right-hand corner of RStudio. If you want to see some of the built-in help whilst using code completion, you can hit F1. Similarly, you can select a word in script and hit F1 to go to the help. If you don’t have something specific to select from you can go to the help window and use the search facility. If there’s a function that matches what you’re typing that’ll be shortlisted, and you can select it and hit Enter alternatively if you don’t get a match, hitting Enter once you’ve finished typing will enact a fuzzier search. Another way you can get help is by looking at the index of functions available for a given package. You go to the Packages tab and click on the package you’re interested in. This loads up the index for that package and you can then read through what’s available. The help window has some handy navigation features to make it easier to use: In-file search bar for finding words in a help file Navigation arrows for moving between files like Back and Forwards on a web-browser. The New Window button creates a popup with the file so that you make it bigger or put it onto another monitor. 4.2 Online R is a great community that has produced many resources. You can search for previous R questions or ask new ones on the ubiquitous Stack Overflow. If you’re tweeting about R, use the hashtag #rstats. If you want to see what’s happening in the R world, I recommend you follow Mara Averick (@dataandme). RStudio provide a trove of fantastic cheatsheets – including one for being super-productive in RStudio. These are great to download and/or print in order to keep handy as you’re learning. Documentation for R packages is available on CRAN but there a number of online sites that try to iprove the experience, including rdrr.io and rdocumentation.org. R-bloggers is a site consolidating blogs from more than 500 people. It’s a great way to find how-tos. R Weekly is a curated newsletter of key goings on, new packages, and blog posts from the R world. 4.3 In-person The R community as well as having doing a huge amount of tweeting, actually gets together in-person quite a bit. If you’d like to go a meetup, then you should check out this meetup directory. As well as these happenings, you can also check out R-Ladies events. We have a growing number of conferences and you can find ones to attend via the conferences directory. "],
["r-data-types.html", "5 R data types 5.1 Numbers 5.2 Text 5.3 Logical values 5.4 Dates 5.5 Summary 5.6 R Data Types Exercises", " 5 R data types I recommend you add a new file to your R project, save it with a file name referencing this section and try out the code. Add your answers to the exercises and leave yourself some notes by first putting # sign and then typing the note after it. There’s nothing like practice and taking notes for helping you retain info! When we think of different bits of data, some of it might be numbers, text, dates, and more. R has it’s own set of these data types. Before we get into the data types, let’s see how we can get R to tell us what something is. R uses functions to take some inputs and get an output. The function that we can pass a value and get what data type it is as the output if the class() function. class(1) class(1.1) class(&quot;1&quot;) ## [1] &quot;numeric&quot; ## [1] &quot;numeric&quot; ## [1] &quot;character&quot; You can use this class() function if you’re ever unsure what data type something is. This is great for when you’re getting unexpected results! 5.1 Numbers I gloss over a lot of the nuance here as most people will not need it. If you want some of the nuance, read the footnotes. Numbers are split into a few different of types: integers are whole numbers like 1 or 427 numerics are numbers that have a decimal portion associated with them like 1.0 or 3.1338 complex numbers are numbers that make use of the imaginary number i like 4i.9 5.1.1 Converting to numbers The functions as.numeric() and as.integer() allow you to convert something stored as text into a number. These functions will give you some red text as a warning if you attempt to convert something to a number that can’t be safely converted. It will still have performed the conversion though. as.numeric(1) as.numeric(1.1) as.numeric(&quot;1&quot;) as.numeric(&quot;r&quot;) ## Warning: NAs introduced by coercion as.integer(1) as.integer(1.1) as.integer(&quot;1&quot;) as.integer(&quot;r&quot;) ## Warning: NAs introduced by coercion ## [1] 1 ## [1] 1.1 ## [1] 1 ## [1] NA ## [1] 1 ## [1] 1 ## [1] 1 ## [1] NA 5.1.2 Checking numbers You can write checks to see if something is numeric, or an integer, with is.numeric() or is.integer(). is.numeric(1) is.numeric(&quot;1&quot;) is.integer(1) is.integer(1L) # Read the footnote on integers for info on this notation is.integer(&quot;1&quot;) ## [1] TRUE ## [1] FALSE ## [1] FALSE ## [1] TRUE ## [1] FALSE We could also use class() here and inspect the result.10 I’m going to use it here to test the results of a conversion to show you how you can nest functions, which means that the inner-most function gets evaluated and the results are used by the next outer-most function, and so on. class(numeric(&quot;1&quot;)) class(integer(&quot;1&quot;)) ## [1] &quot;numeric&quot; ## [1] &quot;integer&quot; 5.1.3 Special numbers As well as i to denote imaginary numbers, there are some additional symbols you might encounter or want to use. pi = 3.1415927 Inf represents positive infinity. You’ll often see this if you divide a positive number by zero. -Inf represents negative infinity. You’ll often see this if you divide a negative number by zero. NaN is what happens when you really screw up a calculation and do something like 0/0. 5.2 Text Text, also known as strings, is split up into two core types: characters are text as we typically think of it like “red” factors (and the subtype ordered factors) are a text type where the number of unique values is constrained e.g. the values are selected from a dropdown. It’s not very space-efficient to store everything as text. Factors basically assign each unique value an ID and store the ID. Then when we return the data, it replaces the ID with the text.11 Factors will be covered at length in a later book. The rest of this book will work with characters. In R, you can’t just type some text as it will be construed as an object or function name. To delimit a string you can use speech marks (&quot;) or apostrophes (') at the beginning and end of it to show where it starts and ends. Note you can’t use the two delimiters interchangably e.g. “red’ but you can use them together to enable you have speech marks or apostrophes inside a string e.g. ‘They said “Read this”’ or”It’s mine now“. If you need to have both inside a string you can escape the ones on the iside of a string to say they don’t count as text delimiters. To escape a delimiter you can use a backslash(\\) e.g. “They said &quot;Read this&quot;”. Beware the copy &amp; pasting (C&amp;Ping) of code that isn’t in “pre-formatted” mode. The aesthetically pleasing changing of speechmarks at the beginning and end of some text will screw up your code. If you’re getting weird errors around unexpected symbols or your console queuing up after C&amp;Ping, replace all the speechmarks and see if that fixes things. This can also happen with some types of space characters too. 5.2.1 Converting to strings Converting to characters and factors is the same as working with numbers. You swap “numeric” for “character” or “factor” and you’re done! You’ll see a difference in how these values get displayed. Basic characters are boring - they just print out. Factors look very different. There’s no speech marks and there’s this Levels bit. The Levels tells you what the unique values in the lookup for this datatype are. as.character(1) as.character(&quot;1 a&quot;) as.factor(1) as.factor(&quot;1 a&quot;) ## [1] &quot;1&quot; ## [1] &quot;1 a&quot; ## [1] 1 ## Levels: 1 ## [1] 1 a ## Levels: 1 a 5.2.2 Checking strings We can check text in a similar way to checking numbers. is.character(1) is.character(&quot;1&quot;) is.factor(1) is.factor(&quot;1&quot;) is.factor(as.factor(&quot;1&quot;)) ## [1] FALSE ## [1] TRUE ## [1] FALSE ## [1] FALSE ## [1] TRUE Additionally, the class() function returns the datatype. class(&quot;1&quot;) class(as.factor(&quot;1&quot;)) ## [1] &quot;character&quot; ## [1] &quot;factor&quot; 5.3 Logical values Whilst we’ve been testing our datatypes, we’ve created a lot of logical or boolean values. Booleans values are TRUE and FALSE. R is case-sensitive so these have to be typed uppercase, otherwise it means something different. You can think of the boolean values as 1 and 0, but using these in your code can result in changing your datatype to a number. If things aren’t working as expected make sure to check types as you go along. 5.3.1 Converting to logicals TRUE #cases as.logical(1) as.logical(&quot;TRUE&quot;) as.logical(&quot;true&quot;) FALSE #cases as.logical(0) as.logical(&quot;FALSE&quot;) as.logical(&quot;false&quot;) ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] FALSE ## [1] FALSE ## [1] FALSE ## [1] FALSE 5.3.2 Checking logicals There is support for checking if something is of datatype logical. is.logical(1) is.logical(TRUE) is.logical(&quot;TRUE&quot;) class(TRUE) ## [1] FALSE ## [1] TRUE ## [1] FALSE ## [1] &quot;logical&quot; 5.4 Dates Dates are one of the hardest parts of programming! This is a very brief introduction to dates and they will not be covered further in this book. Expect a later book to dedicate a lot of page space to date handling. Dates in R split into: dates do not have any time component POSIX datetimes POSIXct is an integer based storage method POSIXlt is a component based storage method You might be looking at the two POSIX times and thinking to yourself “ZOMG how am I meant to choose?”. Most people use the POSIXct format12, which is the default for many of R’s functions. 5.4.1 Converting to dates You can convert to datetime’s with as.Date(),as.POSIXct(), and as.POSIXlt(). Ideally, you’ll provide a string with the date(time) in ISO8601 formats e.g. “YYYY-MM-DD hh:ss”. If not, you’ll want to read up on the datetime format specifications for R. as.Date(&quot;2017-12-31&quot;) as.POSIXct(&quot;2017-12-31&quot;) as.POSIXlt(&quot;2017-12-31&quot;) as.Date(&quot;2017-12-31 23:59&quot;) as.POSIXct(&quot;2017-12-31 23:59&quot;) as.POSIXlt(&quot;2017-12-31 23:59&quot;) ## [1] &quot;2017-12-31&quot; ## [1] &quot;2017-12-31 GMT&quot; ## [1] &quot;2017-12-31 GMT&quot; ## [1] &quot;2017-12-31&quot; ## [1] &quot;2017-12-31 23:59:00 GMT&quot; ## [1] &quot;2017-12-31 23:59:00 GMT&quot; Note that it’s assuming a timezone based on my device as I’ve not provided a default. It’s prudent to set the timezone in order to avoid the results of your code changing based on where the code is run or when13. as.POSIXct(&quot;2017-12-31 23:59&quot;, tz = &quot;UTC&quot;) ## [1] &quot;2017-12-31 23:59:00 UTC&quot; 5.4.2 Checking dates Unfortunately, R does not provide functions for checking whether the class of something is a datetime type wihtout extending it’s functionality. We have to use class() as a consequence. class(as.Date(&quot;2017-12-31&quot;)) class(as.POSIXct(&quot;2017-12-31&quot;)) class(as.POSIXlt(&quot;2017-12-31&quot;)) ## [1] &quot;Date&quot; ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; ## [1] &quot;POSIXlt&quot; &quot;POSIXt&quot; You’ll see that the POSIX values not only returns the class we expected but “POSIXt” as well. POSIXt is an interchange format behind the scenes of dates in R. You don’t directly use it and you can ignore it from here on in. 5.4.3 Getting dates and times R has some functions for getting current datetime values14. Sys.Date() Sys.time() Sys.timezone() ## [1] &quot;2017-08-11&quot; ## [1] &quot;2017-08-11 18:51:54 BST&quot; ## [1] &quot;Europe/London&quot; 5.5 Summary There a few more datatypes out in the wild but numbers, strings, booleans, and dates are the core types you’ll encounter. There are normally as.* and is.* functions for converting to a datatype or checking if omething is a given datatype. You can use class() to uncover the datatype too. Data type Example Integer 1 Logical TRUE Numeric 1.1 String / character “Red” Factor (enumerated string) “Amber” or 2 in c(“Red”,“Amber”,“Green”) Complex i Date “2017-08-11” 5.6 R Data Types Exercises Convert TRUE to an integer What is the datatype of the value returned by Sys.time()? What is the datatype of the value returned by Sys.timezone()? Make this quote into an R string &gt; “Do you think this is a game?”, he said. “No I think Jenga’s a game”, Archer responded. If you want to guarantee a number is an integer, you can suffix the value with a L e.g. 42L. If you want to read more about this, check out the R manual↩ Numerics in R are floating point numbers - this mean every decimal gets stored usually with a large amount of extra decimal places. This can lead to some unusual results when comparing two decimal values and we’ll see an example later.↩ i is the square root of -1, which is an impossible number since any negative multiplied by itself would result in a positive. Descartes coined the term “imaginary” in reference to this number as it’s a consistent value in formulae but doesn’t exist in the real world.↩ You might recall that class(1) had the result of “numeric” - R was not by default considering 1 as an integer for the purpose of the class() function. This is a property of R’s evaluation of values and you can force it consider a value to be an integer by suffixing it with an L so class(1L) evaluates to “integer”.↩ In other programming languages this is often called an enumerated string↩ According to my unscientific twitter poll↩ Daylight savings time can catch you out↩ This is an area showing those wonderful R quirks - the Sys.* functions are inconsistently cased↩ "],
["basic-operations.html", "6 Basic operations 6.1 Maths 15 6.2 Comparison 6.3 Logic 6.4 Summary 6.5 Basic Operations Exercises", " 6 Basic operations Now that we have some datatypes, we can start learning what we can do with them. 6.1 Maths 15 In R, we have our common operators that you’re probably used to if you’ve performed calculations on computers before. Action Operator Example Subtract - 5 - 4 = 1 Add + 5 + 4 = 9 Multiply * 5 * 4 = 20 Divide / 5 / 4 = 1.25 Raise to the power ^ 5 ^ 4 = 625 R adheres to BODMAS16 so you can construct safe calculations that combine operators in reliable ways. (1 + 2^3) - 5 * (4/2) ## [1] -1 Additionally, there are some other operators worth knowing about. Action Operator Example Integer division %/% 9 %/% 4 = 2 Modulus %% 9 %% 4 = 1 Basic sequence : 1:3 = 1, 2, 3 The colon (:) is a really snazzy way of generating a sequence of numbers that step by 1. 1:5 5:1 -1:5 5:-1 ## [1] 1 2 3 4 5 ## [1] 5 4 3 2 1 ## [1] -1 0 1 2 3 4 5 ## [1] 5 4 3 2 1 0 -1 Integer division (%/%) tells you how many times the first number can be divided by the second without returning a fractional value. 1:8 1:8%/%3 1:8%/%4 ## [1] 1 2 3 4 5 6 7 8 ## [1] 0 0 1 1 1 2 2 2 ## [1] 0 0 0 1 1 1 1 2 The modulus (%%) tells you how much is left over after performing an integer division. 1:8 1:8%%3 1:8%%4 ## [1] 1 2 3 4 5 6 7 8 ## [1] 1 2 0 1 2 0 1 2 ## [1] 1 2 3 0 1 2 3 0 For reasons17 not worth worrying about, R uses the % sign as the start of special operators – usually these are custom built, contain text, or reserved symbols. 6.2 Comparison The next important thing to know about is how to write comparisons. 6.2.1 Common operators The less thans and greater thans are symbols that are in pretty much every language for comparisons, but the test to see if two values are the same or not can often vary across languages. 2 &lt; 3 3 &gt; 2 2 &gt;= 2 2 &lt;= 2 ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE In R, you test if two values are exactly the same with == and you test if they’re different with !=. 2 == 2 2 != 2 ## [1] TRUE ## [1] FALSE You can test if a value is present in a list of acceptable values using the %in% operator. This may seem a little trivial right now, but once we start covering more than one value at a time, it’ll start showing it’s uses for strings. 2 %in% 1:3 ## [1] TRUE 6.2.2 A gotcha Testing for equality can get a little weird with R because it uses a different way of storing numbers than we would expect. It doesn’t store numbers quite as precisely as we expect - somewhere at the very end of a large number of decimal places, the value can be rounded incorrectly. It doesn’t make a difference to most of our calculations but it will often hit when you’re comparing two decimal values. Let’s see an example. Both these calculation return what we think of as 0.2 0.5 - 0.3 0.6 - 0.4 ## [1] 0.2 ## [1] 0.2 Indeed, if we test 0.2 is the same as 0.2 we get a TRUE which matches our expectations. 0.2 == 0.2 ## [1] TRUE But, when we perform two calculations, even though they come out to the same value to us, there’s a little bit of imprecision in how they’re stored that stops from being exactly the same number. (0.6 - 0.4) == (0.5 - 0.3) ## [1] FALSE To avoid this issue, if you’re comparing decimal values that result from calculations it is better to use the all.equal() function. all.equal() adds a tolerance to the comparison which means the very subtle imprecision is ignored. The default tolerance is 1.510^{-8}, in other words the imprecision is very, very small. all.equal(0.6 - 0.4, 0.5 - 0.3) ## [1] TRUE 6.2.3 Summary Action Operator Example Less than &lt; 5 &lt; 5 = FALSE Less than or equal to &lt;= 5 &lt;= 5 = TRUE Greater than &gt; 5 &gt; 5 = FALSE Greater than or equal to &gt;= 5 &gt;= 5 = TRUE Exactly equal == (0.5 - 0.3) == (0.3 - 0.1) is FALSE, 2 == 2 is TRUE Not equal != (0.5 - 0.3) != (0.3 - 0.1) is TRUE, 2 != 2 is FALSE Equal all.equal() all.equal(0.5 - 0.3,0.3 - 0.1) is TRUE In %in% &quot;Red&quot; %in% c(&quot;Blue&quot;,&quot;Red&quot;) is TRUE 6.3 Logic Once we can do a single check, we inevitably want to do multiple checks at the same time. To combine multiple checks, we can use logical operators. 6.3.1 Common operators The ampersand (&amp;) allows us to combine two checks to do an AND check which is “are both things true”. TRUE &amp; TRUE TRUE &amp; FALSE FALSE &amp; FALSE (2 &lt; 3) &amp; (4 == 4) (2 &lt; 3) &amp; (4 != 4) ## [1] TRUE ## [1] FALSE ## [1] FALSE ## [1] TRUE ## [1] FALSE The pipe / bar (|)18 allows us to do an OR check which is “are either of these things true”. TRUE | TRUE TRUE | FALSE FALSE | FALSE (2 &lt; 3) | (4 == 4) (2 &lt; 3) | (4 != 4) ## [1] TRUE ## [1] TRUE ## [1] FALSE ## [1] TRUE ## [1] TRUE The exclamation point (!) allows us to a perform a NOT by negating or swapping a check’s result. This allows you say things like “is this check true and that check not true”. TRUE &amp; TRUE TRUE &amp; !FALSE !FALSE &amp; !FALSE (2 &lt; 3) &amp; (4 == 4) (2 &lt; 3) &amp; !(4 != 4) ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE 6.3.2 Other operators Less commonly, there other logical checks you might to perform. We can do an XOR, where one and only one of two values being checked is true. xor(TRUE, FALSE) xor(TRUE, TRUE) xor(FALSE, FALSE) ## [1] TRUE ## [1] FALSE ## [1] FALSE We’ll see how this works in the next section, but when we use our logical operators it will do the comparison for every row. Sometimes we might be performing comparisons for many values but we need to to guarantee we get just one value back. We can use variants or AND and ORs called bitwise comparisons to achieve this. Use these with care as the results can be a little bit weird! TRUE &amp;&amp; TRUE TRUE &amp;&amp; FALSE TRUE || TRUE TRUE || FALSE 1:2 &gt; 1 2:3 &gt; 1 1:2 &gt; 1 &amp;&amp; 2:3 &gt; 1 ## [1] TRUE ## [1] FALSE ## [1] TRUE ## [1] TRUE ## [1] FALSE TRUE ## [1] TRUE TRUE ## [1] FALSE 6.3.3 Summary We can produce sophisticated checks from a few simple building blocks. This will come in very handy down the line when doing things like filtering datasets or creating new fields in your data. Action Operator Example Not ! !TRUE is FALSE And &amp; TRUE &amp; FALSE is FALSE, c(TRUE,TRUE) &amp; c(FALSE,TRUE) is FALSE, TRUE Or | TRUE | FALSE is TRUE, c(TRUE,FALSE) | c(FALSE,FALSE) is TRUE, FALSE Xor xor() xor(TRUE,FALSE) is TRUE Bitwise And &amp;&amp; c(TRUE,TRUE) &amp;&amp; c(FALSE,TRUE) is FALSE Bitwise Or || c(TRUE,FALSE) || c(FALSE,FALSE) is TRUE 6.4 Summary This basic operations section has taught how to manipulate values and consstruct comparisons. These are important building blocks in ddata analysis, and whilst we’ve been working with only a single value at a time, in the next section we’ll see how it works with more data. Action Operator Example Subtract - 5 - 4 = 1 Add + 5 + 4 = 9 Multiply * 5 * 4 = 20 Divide / 5 / 4 = 1.25 Raise to the power ^ 5 ^ 4 = 625 Less than &lt; 5 &lt; 5 = FALSE Less than or equal to &lt;= 5 &lt;= 5 = TRUE Greater than &gt; 5 &gt; 5 = FALSE Greater than or equal to &gt;= 5 &gt;= 5 = TRUE Exactly equal == (0.5 - 0.3) == (0.3 - 0.1) is FALSE, 2 == 2 is TRUE Not equal != (0.5 - 0.3) != (0.3 - 0.1) is TRUE, 2 != 2 is FALSE Equal all.equal() all.equal(0.5 - 0.3,0.3 - 0.1) is TRUE In %in% &quot;Red&quot; %in% c(&quot;Blue&quot;,&quot;Red&quot;) is TRUE Not ! !TRUE is FALSE And &amp; TRUE &amp; FALSE is FALSE, c(TRUE,TRUE) &amp; c(FALSE,TRUE) is FALSE, TRUE Or | TRUE | FALSE is TRUE, c(TRUE,FALSE) | c(FALSE,FALSE) is TRUE, FALSE Xor xor() xor(TRUE,FALSE) is TRUE Bitwise And &amp;&amp; c(TRUE,TRUE) &amp;&amp; c(FALSE,TRUE) is FALSE Bitwise Or || c(TRUE,FALSE) || c(FALSE,FALSE) is TRUE 6.5 Basic Operations Exercises What is the result of pi^2? Is pi greater than 3? Construct a statement to check if 5 is both greater than 3 and less than or equal to 6 What are the results if you check to see if a sequence of 1 to 5 is less than or equal to 3? I’m British, deal with it.↩ Brackets, Other, Division, Multiplication, Addition, Subtraction↩ Read Rbitrary for more info↩ Getting this symbol can be painful as it varies substantially by keyboard, so apologies if it takes you a while to hunt this symbol down.↩ "],
["r-objects.html", "7 R objects 7.1 Storing values 7.2 Vectors 7.3 Getting information about vectors 7.4 Calculations on multiple vectors 7.5 data.frames 7.6 Importing data.frames 7.7 Getting information about data.frames 7.8 Lists 7.9 Getting information about lists 7.10 Other object types 7.11 Useful functions 7.12 R objects exercises", " 7 R objects So far we’ve just worked with some single values to get to grips with how some of the various operations work. Of course, we rarely work with a single value! If we did, we could just use a calculator. This section helps you get to grips with some different ways of storing data and how to manipulate your datasets in the “traditional” way. This is useful because you can understand a lot of code written in the past and equips you to understand the material in the next book, which focusses on data manipulation of tabular data. 7.1 Storing values When we were performing operations, we got some values output to the console. One of the key principles in writing code is Don’t Repeat Yourself (DRY) so we need to know how we can avoid repeating ourself in R. One of the ways you can do that is to store a value for use later. In R, we can store values by assigning them a name. This makes a variable or object. We can do this with a few different operators, but the traditional operator is a &lt;-19. The format for assigning a value is nameofthing &lt;- value. my_variable &lt;- 5 + 3 my_variable &gt; 6 &amp; my_variable &lt; 10 ## [1] TRUE Valid names for a variable include upper case letters, lower case letters, numbers anywhere but the beginning, periods (.), and hyphens (_). There are a number of different competing conventions for how you name variables. The most common conventions are shown below. I have no strong feelings for any system and only ask that at minimum you’re pick one and stick with it within a single script. Whatever you do, don’t forget names are case sensitive! myfirstvariable &lt;- 1 myFirstVariable &lt;- 1 MyFirstVariable &lt;- 1 my_first_variable &lt;- 1 my.first.variable &lt;- 1 You can create names breaking the rules governing valid names by placing the rule breaking name between two backticks (`). I don’t recommend you do this with variables you’ll create, but you’ll often end up with names that break conventions when importing data, especially when you import from spreadsheets. `name with spaces` &lt;- 1 `2017` &lt;- 1 ` ` &lt;- 1 `$$$` &lt;- 1 Variables you store get stored in-memory. This means they’ll hang around whilst R is open and will be gone after that. You can see variables you’ve created RStudio will by default save your variables for you so that next time you open it up, your variables are stored. RStudio saving your variables is a blessing because you don’t have to worry about keeping RStudio open the all time. It’s also a pretty major curse because you’ll inevitably create something at some point through the console or an Untitled R file and then lose that bit of code. Now when you’re script runs in a fresh session it’ll fail. You’ll risk tearing your hair out and worse as you go through the pain of debugging this. I recommend you get in the habit early of not working with your session being saved. Turn it off in Tools &gt; Global Options, untick “Restore .RData into workspace at startup” If you need to manage what’s been stored you can list objects with ls() and remove them with rm(). If you want to remove everything you can usels() inside rm(). today &lt;- Sys.Date() rm(&quot;today&quot;) ls() rm(list = ls()) ## [1] &quot; &quot; &quot;$$$&quot; &quot;2017&quot; ## [4] &quot;allmydata&quot; &quot;earlyletters&quot; &quot;letters&quot; ## [7] &quot;model&quot; &quot;my.first.variable&quot; &quot;my_first_variable&quot; ## [10] &quot;my_variable&quot; &quot;mydf&quot; &quot;myfirstvariable&quot; ## [13] &quot;myFirstVariable&quot; &quot;MyFirstVariable&quot; &quot;mylist&quot; ## [16] &quot;myPlot&quot; &quot;name with spaces&quot; &quot;predictions&quot; ## [19] &quot;steph&quot; &quot;test_data&quot; &quot;test_outcome&quot; ## [22] &quot;training_data&quot; &quot;training_outcome&quot; &quot;vecA&quot; ## [25] &quot;vecB&quot; Another way you can remove a single object is to overwrite the object with value NULL. today &lt;- Sys.Date() today &lt;- NULL If you want to clear everything you can also use the broom symbol in the Environment tab in RStudio. 7.2 Vectors A vector is a collection of values that hold the same datatype. It is one-dimensional in that none of the elements in the collection correspond to other values like they might in a table of values. A single value is actually a vector of length 1. When I introduced the colon (:) as a means on generating a sequence, we were in fact generating a vector where each element was a number in the sequence. The vector has a length as long as the number of values generated by the sequence. -1:1 ## [1] -1 0 1 Another way of producing a vector is to use the combine function (c()). This is great for combining a number of disparate character strings into a vector. c(&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;) ## [1] &quot;red&quot; &quot;yellow&quot; &quot;blue&quot; A single value is a still a vector. What we see when we use the c() function is that we’re combining vectors. As a result we can also use it on longer vectors too. c(1:3, 2:1, 5:8) ## [1] 1 2 3 2 1 5 6 7 8 When we combine values into a single vector, R will change everything to the same datatype using some conversions. c(1, FALSE) c(1, &quot;FALSE&quot;) ## [1] 1 0 ## [1] &quot;1&quot; &quot;FALSE&quot; This implicit conversion is something to be careful of and can really screw up your results! If in doubt, check the datatype with the class() function, or look for the vector in your global environment and see what the datatype is from there. We can also give names to values being included in a vector. c(first = &quot;Steph&quot;, last = &quot;Locke&quot;) ## first last ## &quot;Steph&quot; &quot;Locke&quot; 7.3 Getting information about vectors Our class() function will still work with a vector with a length greater than 1 to get you it’s datatype. class(1:10) LETTERS class(LETTERS) ## [1] &quot;integer&quot; ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; ## [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; ## [1] &quot;character&quot; We can use the length() function to find out the number of elements in a vector. length(pi) length(LETTERS) ## [1] 1 ## [1] 26 To extract the names of values in a vector, we can use the names() function. steph &lt;- c(Steph = &quot;forename&quot;, Locke = &quot;surname&quot;) names(steph) ## [1] &quot;Steph&quot; &quot;Locke&quot; 7.4 Calculations on multiple vectors When we perform calculations on two vectors, R will try to perform the operation for each set of elements. This is an element-wise calculation methodology. In SQL, it’s equivalent to where you might write colA*colB and you’ll get the answer calculated for every row in the table. In Excel, it’s equivalent to a Fill Down of multiplying two values on the same row. Let’s looks at how this works in practice in R. We have two vectors, each containing two elements. vecA &lt;- 1:2 vecB &lt;- 2:3 If we want to multiply the two vectors by each other, R will match each element in the first vector with it’s counterpart in the second and multiply the two values together to make a new element. vecA * vecB ## [1] 2 6 We can also do this with vectors of different lengths to a certain extent. The most common scenario is operating on a vector by doing something with a single value. A single value is a vector of length 1. When R gets a request to do something with a vector of length X and a vector of length 1, it will basically repeat the vector of length 1 X times to make two vectors the same length. It wil then perform the calculation element-wise. vecA * 3 ## [1] 3 6 You can also use this functionality of making a vector the same length as another, known as recycling, work for other mis-matched vector sizes. The only rule is the one of the vector lengths must divide cleanly by the other. Two vectors of the same length divide by the other’s length exactly one time and won’t need to recycle. A vector of length one always cleanly divides any other vector’s length and so will be recycled. A vector of length 2, will divide any vector with an even length and so will be recycled in those cases, but it cannot recycle cleanly for odd length vectors. 1:10 * 2 1:10 * 2:3 1:10 * 2:4 ## Warning in 1:10 * 2:4: longer object length is not a multiple of shorter ## object length ## [1] 2 4 6 8 10 12 14 16 18 20 ## [1] 2 6 6 12 10 18 14 24 18 30 ## [1] 2 6 12 8 15 24 14 24 36 20 Vector recycling is useful and dangerous – it can help you make elegant code or give you unexpected results. Especially when starting out, I recommend you make your vectors either the same length or length 1. 7.5 data.frames A data.frame is table similar to what we’re used to working with in most data analysis tools. It will contain a number of rows with columns containing different pieces of information. Each column in a data.frame has a datatype but it does not have to the same datatype as the other columns. We can construct a data.frame from individual vectors via the data.frame() function. data.frame(a = 1:2, b = c(&quot;blue&quot;, &quot;red&quot;)) ## a b ## 1 1 blue ## 2 2 red You can also give row names to the rows you end up making, however, I recommend you add these in as a column instead. data.frame(a = 1:2, b = c(&quot;blue&quot;, &quot;red&quot;), row.names = c(&quot;First&quot;, &quot;Second&quot;)) ## a b ## First 1 blue ## Second 2 red Throughout many of the examples, I’ll use the example datasets that are available by default in R. View(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa The View() function is specific to RStudio and provides a nice visual grid view of a data.framae and it allows you to search and sort the table for some initial exploration. More commonly, we’ll import data an outside source. 7.6 Importing data.frames You can import data via code, but one of the eassiest ways of getting started is to load data via RStudio and have it generate the code for you. To import data, go to the Environment tab and select Import Dataset. Select the relevant type of data you want to import. Browse to the file you want to upload. Keeping data in the project directory is ideal as it keeps everything in one place and makes import code easier to read. You can tweak the advanced settings and then select the Import button to load the data directly into memory. Alternatively, you can copy the code it generated for you and paste it into a script. By doing this copy and pasting, you will make the import reproducible. Next time you need to load the data you can just run the code, instead of using the interface again. 7.6.1 Error!! If you were tying to do this import and you have a fresh installation of R and RStudio, you probably got an error when you tried to load a file because you don’t have some of the required functionality that RStudio expects you to have. It will tell you the name of the thing you’re missing. In my case - I’m missing the package “readr”. To make this available to us, we go to the Packages tab and then: select Install type “readr” select the Install button accept any popups for things like restarting R 7.7 Getting information about data.frames Our data.frames are composites, they are the result of combining a number of vectors with different data types. As a consequence, when we run our class() function, it tells us an object is a data.frame and no longer returns the underlying datatype. class(iris) ## [1] &quot;data.frame&quot; You do not get the number of rows in a data.frame when you run the length() function, instead you get the number of columns20. Alternatively, you can run the more clearly named ncol() function to return the number of columns in a data.frame. length(iris) ncol(iris) ## [1] 5 ## [1] 5 You can get the number of rows via the nrow() function. nrow(iris) ## [1] 150 Similarly to length(), the names() function when applied to data.frame’s only works on the columns, so you can use it to get column names. A clearer alternative is to use the colnames() function. You can use rownames() to get names for rows, if they exist. mydf &lt;- data.frame(a = 1:2, b = c(&quot;blue&quot;, &quot;red&quot;), row.names = c(&quot;First&quot;, &quot;Second&quot;)) names(mydf) colnames(mydf) rownames(mydf) ## [1] &quot;a&quot; &quot;b&quot; ## [1] &quot;a&quot; &quot;b&quot; ## [1] &quot;First&quot; &quot;Second&quot; 7.8 Lists Lists are your catch-all object. An element in a list can be any object, including a list! You’ll usually find yourself using a list when you’re receiving some nested data (like from some API response) or when you want to bundle multiple connected pieces of information together. Most functionality for building statistical models in R will return a list object holding things like the model coefficients, key statistics, and fitted values. You can create lists with the list() function and like with our other objects you can have named and unnamed elements. mylist &lt;- list(a = 1:3, LETTERS) mylist ## $a ## [1] 1 2 3 ## ## [[2]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; ## [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; 7.9 Getting information about lists The length() function will tell you how many elements there are in a list. length(mylist) ## [1] 2 names() lets you get the element names and returns a blank (&quot;&quot;) where no name was provided. names(mylist) ## [1] &quot;a&quot; &quot;&quot; 7.10 Other object types There a number of other object types in R. They won’t be covered in detail in this book, because they tend to be used by a small fraction of R users. A matrix is two-dimensional object that can only one datatype. An array is a multi-dimensional object that can contain only one datatype. A table object is similar to a matrix but is created by producing a contingency table. In R, developers can also create other object types specific to their requirements. People use this to create geospatial objects and more. 7.11 Useful functions Whatever the object type, there some functions that come in handy for You get the contents of any object by writing it’s name. mylist ## $a ## [1] 1 2 3 ## ## [[2]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; ## [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; However, if you’re working with a lot of data, you probably don’t want to fill up your console that way. R has two functions, head() and tail(), which allow you to see values from beginning or end of an object. head(LETTERS) tail(LETTERS) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; ## [1] &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; If you want to examine an R object, you can use the str() function to get the structure of the object. str(mylist) ## List of 2 ## $ a: int [1:3] 1 2 3 ## $ : chr [1:26] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... 7.12 R objects exercises See what’s in the variable letters; Write a check to see if “A” is present in letters; Find out which values in the sequence 1 to 10 are greater than or equal to 3 and less than 7. Make a vector containing the numbers 1 to 50; Make a vector containing two words; What happens when you combine these two vectors? Make a data.frame using the two vectors What happened to your text vector? Make a list containing some of the variables you’ve created so far. Return the some rows from the iris dataset Other valid values are the equals symbol = and you can also do a right-handed assignment with -&gt;↩ This is because a data.frame is actually just a prettily printed list and each column in an element in said list and length returns the number of elements.↩ "],
["data-manipulation.html", "8 Data manipulation 8.1 Grid references 8.2 Grid references with numbers 8.3 Grid references with names 8.4 Grid references with conditional values 8.5 Other reference methods 8.6 Changing objects 8.7 Data manipulation exercises", " 8 Data manipulation 8.1 Grid references With R objects, it’s possible to use a grid reference system to select values out of an object. In vectors and lists, you can specify the element position as they’re only have a single dimension. In data.frames, you can pinpoint both the element (row) and the column. You can provide a grid reference by adding square brackets after a name e.g. mylist[ ]. Inside the square brackets, we can provide values in a few different ways to extract parts of the object. If you want everything in an object, you can just use the object’s name or put square brackets after it. letters letters[] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; ## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; ## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; 8.2 Grid references with numbers To select a specific element, you provide the number indicating it’s position in the object.21 letters[2] mylist[1] ## [1] &quot;b&quot; ## $a ## [1] 1 2 3 In a data.frame, you can provide one or two values. These are comma seperated inside the square brackets and row numbers get specified first e.g. iris[ row , column ]. If you want to select all rows or all columns you leave that part of the reference blank e.g. iris[1, ] to return the first row and iris[ ,2] to return the second column. mydf &lt;- data.frame(a = 1:5, b = 6:10, c = 11:15) mydf[1, ] mydf[, 1] mydf[3, 3] ## a b c ## 1 1 6 11 ## [1] 1 2 3 4 5 ## [1] 13 Since even a single value is a vector in R, it means we can provide longer vectors in our grid specifications. letters[1:5] mydf[1:3, c(1, 2)] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; ## a b ## 1 1 6 ## 2 2 7 ## 3 3 8 As well as positive specifications, we can also use negative values. These tell R which bits of the grid that you don’t want. letters[-5:-1] mydf[-3, -2] ## [1] &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; ## [18] &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; ## a c ## 1 1 11 ## 2 2 12 ## 4 4 14 ## 5 5 15 If you specify an position that doesn’t exist, R will return an NA (a missing value) for that position. letters[23:29] ## [1] &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; NA NA NA 8.3 Grid references with names Where names are used, we can provide these names in our grid references. mylist[&quot;a&quot;] mydf[, c(&quot;a&quot;, &quot;b&quot;)] ## $a ## [1] 1 2 3 ## ## a b ## 1 1 6 ## 2 2 7 ## 3 3 8 ## 4 4 9 ## 5 5 10 You cannot provide a mix of element positions and element names in a single vector because the numbers would get converted to strings and be checked as character-based names. mylist[c(1, &quot;a&quot;)] ## $&lt;NA&gt; ## NULL ## ## $a ## [1] 1 2 3 You are able to use element positions and element names in data.frame selections if you stick to one type of reference in each position. mydf[1:2, c(&quot;a&quot;, &quot;b&quot;)] ## a b ## 1 1 6 ## 2 2 7 8.4 Grid references with conditional values Whilst we often want to subset data.frames to some specific columns, a lot of the time with vectors and data.frames we want to be able to apply a condition that determines which values are returned. If you provide boolean values into our grid reference system it will return elements that have a TRUE associated with it, and ignore values with a FALSE associated with it. mydf[, c(TRUE, FALSE, TRUE)] ## a c ## 1 1 11 ## 2 2 12 ## 3 3 13 ## 4 4 14 ## 5 5 15 R will perform the recycling we saw in the section about working with vectors. So for instance, if we want to return every other letter in the alphabet we could provide a vector of length 2. It would then recycle this vector so TRUE and FALSE alternate for all 26 letters. letters[c(TRUE, FALSE)] ## [1] &quot;a&quot; &quot;c&quot; &quot;e&quot; &quot;g&quot; &quot;i&quot; &quot;k&quot; &quot;m&quot; &quot;o&quot; &quot;q&quot; &quot;s&quot; &quot;u&quot; &quot;w&quot; &quot;y&quot; You might be used to using 0 and 1 as shorthands for boolean values. Unfortunately if you try to use this you find NAs returned for any values you intended to be excluded by using 0, and you’ll get the first value repeated everywhere you used a 1 to indicate inclusion. Hard-coding TRUE and FALSE values is probably not your idea of fun and certainly isn’t mine. We can use our knowledge of building comparisons to generate our booleans for inclusion. earlyletters &lt;- letters &lt;= &quot;e&quot; letters[earlyletters] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; This can be simplified by avoiding the step of creating a variable and using the comparison directly as the grid reference. letters[letters &lt;= &quot;e&quot;] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; We can produce compound comparisons and use those too. letters[letters &lt;= &quot;e&quot; &amp; letters &gt; &quot;b&quot;] ## [1] &quot;c&quot; &quot;d&quot; &quot;e&quot; 8.5 Other reference methods If you need to select a given named value or column from an object, there are some alternative selection methods you do. There are double square brackets for when you expect only, and only one, named element. mylist[[&quot;a&quot;]] ## [1] 1 2 3 There is a much nicer option though for lists and data.frames. That option is using the dollar sign ($) to access named elements. mylist$a mydf$b ## [1] 1 2 3 ## [1] 6 7 8 9 10 The $ methodology has some benefits. It uses fewer characters and you can use code-completion with it. We can use both these notations inside our grid reference system. This becomes very handy for writing row conditions for data.frames. mydf[mydf$a &gt; 3, 1:2] ## a b ## 4 4 9 ## 5 5 10 This is the old-school way of working with data.frames. It’s important to be able to write queries of your data this way, or at least read other people’s code but as soon as you can you should move onto the data.table or tidyverse ways of working with data.frames. The next book in this series will focus on the tidyverse way of working with data.frames. 8.6 Changing objects By utilising our reference systems, not only we can select daata of interest to us, but we can add new data, update existing values, and even delete values. You can update part or all of simple objects by assigning new values against a grid-reference. Adding additional values involves specifying new element positions and providing new data. letters[27] &lt;- &quot;|&quot; tail(letters) mydf[6, ] &lt;- c(pi, Inf, -Inf) mydf ## [1] &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot;|&quot; ## a b c ## 1 1.000000 6 11 ## 2 2.000000 7 12 ## 3 3.000000 8 13 ## 4 4.000000 9 14 ## 5 5.000000 10 15 ## 6 3.141593 Inf -Inf For data.frames, if you want to create a new column, it’s usually much easier to use our $ notation. mydf$d &lt;- 5 mydf ## a b c d ## 1 1.000000 6 11 5 ## 2 2.000000 7 12 5 ## 3 3.000000 8 13 5 ## 4 4.000000 9 14 5 ## 5 5.000000 10 15 5 ## 6 3.141593 Inf -Inf 5 Updating values involves providing a set of values of the same size as the destination. letters[1:3] &lt;- LETTERS[1:3] head(letters) mydf[1, ] &lt;- 1:4 mydf ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; ## a b c d ## 1 1.000000 2 3 4 ## 2 2.000000 7 12 5 ## 3 3.000000 8 13 5 ## 4 4.000000 9 14 5 ## 5 5.000000 10 15 5 ## 6 3.141593 Inf -Inf 5 If you provide something that is not the same size, R will apply the recycling rules. Again, this is nifty and terrible at the same time. mydf[2, ] &lt;- 1:2 If you want to delete values, you can overwrite an object after doing a negative selection. mydf &lt;- mydf[-1, ] mydf ## a b c d ## 2 1.000000 2 1 2 ## 3 3.000000 8 13 5 ## 4 4.000000 9 14 5 ## 5 5.000000 10 15 5 ## 6 3.141593 Inf -Inf 5 An alternative method is to make a selection and assign them the value NULL. NULL can removes contents in lists and data.frames. mydf$c &lt;- NULL mydf mylist[2] &lt;- NULL mylist ## a b d ## 2 1.000000 2 2 ## 3 3.000000 8 5 ## 4 4.000000 9 5 ## 5 5.000000 10 5 ## 6 3.141593 Inf 5 ## $a ## [1] 1 2 3 8.7 Data manipulation exercises Select all LETTERS before “X”; Select the first 5 rows from the built-in data.frame iris; Select the first 2 columns from iris; Select the column Sepal.Length from iris by name. Select rows from the iris data.frame where the Sepal.Length is greater than 5.8cm; Select rows from the iris data.frame where the Sepal.Width is below the average for that column. Select everything from iris except the Species column; Create a copy of the iris data that just contains the first 100 rows and call it myIris; Update the species column to the value “Unknown” in myIris; Delete rows from myIris where the sepal length is greater than 5.5. The first element in an R object is at position 1. This is contrary to a number of programming languages where the first element is at position 0.↩ "],
["r-functions.html", "9 R functions 9.1 Using a function 9.2 Function arguments 9.3 Common functions 9.4 Finding functions 9.5 Seeing how functions work 9.6 Exercises", " 9 R functions 9.1 Using a function A function does some computation on an object. The use of a function consists of: A function’s name; Parentheses; 0 or more inputs. Sys.Date() sum(1:3) ## [1] &quot;2017-08-11&quot; ## [1] 6 9.2 Function arguments Functions can have: 0 arguments e.g. Sys.Date(); all mandatory arguments e.g. length(); optional arguments e.g. sum(); arguments used out of position by using their names e.g. `rnorm(mean=1, n=10). 9.3 Common functions Area Functions Metadata class, mode,length, names, nrow, ncol Measures mean, median, mode, range, sum, cumsum Strings grep, gsub, substr, trim, toupper, paste Files list.dirs, list.files, file.exists 9.4 Finding functions Find functions by: Using code-completion Using help-pages Using ?mean Using ??mean Using apropos(&quot;mean&quot;) 9.5 Seeing how functions work You can examine how many functions work by just typing their name without any parentheses. Sys.Date ## function () ## as.Date(as.POSIXlt(Sys.time())) ## &lt;bytecode: 0x000000001a0611a0&gt; ## &lt;environment: namespace:base&gt; 9.6 Exercises Find a function that involves Normal distributions; Find some functions operate on files. "],
["r-packages.html", "10 R packages 10.1 What is a package? 10.2 Using packages 10.3 Useful packages 10.4 Finding packages 10.5 Package documentation 10.6 Exercises", " 10 R packages 10.1 What is a package? An R package is a bundle of functions and/or datasets. It extends the capabilities that the “base” and “recommended” R packages have. This gives us the ability to do a lot more. 10.2 Using packages Install a package with install.packages(); Load a package with library(); See what’s in a package / reference it without loading packagename::function(); See what’s ina package but not exposed to the public packagename:::function(). 10.3 Useful packages Area Packages Data manipulation dplyr, data.table,tidyr, stringr, forcats Data visualisation ggplot2,leaflet,ggraph Statistics tidytext, caret, broom I/O RODBC, DBI, data.table, readxl Web rvest, httr, urltools Outputs rmarkdown, revealjs, shiny, flexdashboards 10.4 Finding packages 10.5 Package documentation Packages should have documentation at the following levels: Function; Workflow via vignettes; NEWS; DESCRIPTION; READMEs on github. 10.6 Exercises Load the library dplyr; Browse dplyr’s help pages; Read a dplyr introductory vignette; Read dplyr’s README. "],
["answers.html", "A Answers A.1 R Data Types Exercises A.2 Basic Operations Exercises A.3 R Objects Exercises A.4 Data manipulation exercises", " A Answers A.1 R Data Types Exercises Convert TRUE to an integer as.integer(TRUE) ## [1] 1 What is the datatype of the value returned by Sys.time()? class(Sys.time()) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; What is the datatype of the value returned by Sys.timezone()? class(Sys.timezone()) ## [1] &quot;character&quot; Make this quote into an R string &gt; “Do you think this is a game?”, he said. “No I think Jenga’s a game”, Archer responded. &quot;\\&quot;Do you think this is a game?\\&quot;, he said. \\&quot;No I think Jenga&#39;s a game\\&quot;, Archer responded.&quot; ## [1] &quot;\\&quot;Do you think this is a game?\\&quot;, he said. \\&quot;No I think Jenga&#39;s a game\\&quot;, Archer responded.&quot; A.2 Basic Operations Exercises What is the result of pi^2? pi^2 ## [1] 9.869604 Is pi greater than 3? pi &gt; 3 ## [1] TRUE Construct a statement to check if 5 is both greater than 3 and less than or equal to 6 (5 &gt; 3) &amp; (5 &lt;= 6) ## [1] TRUE What are the results if you check to see if a sequence of 1 to 5 is less than or equal to 3? 1:5 &lt;= 3 ## [1] TRUE TRUE TRUE FALSE FALSE A.3 R Objects Exercises See what’s in the variable letters letters ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; ## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot;|&quot; Write a check to see if “A” is present in letters &quot;A&quot; %in% letters ## [1] TRUE Find out which values in the sequence 1 to 10 are greater than or equal to 3 and less than 7. myseq &lt;- 1:10 myseq &gt;= 3 &amp; myseq &lt; 7 ## [1] FALSE FALSE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE Make a vector containing the numbers 1 to 50; fifty &lt;- 1:50 Make a vector containing two words; words &lt;- c(&quot;fifty&quot;, &quot;words&quot;) What happens when you combine these two vectors? c(fifty, words) # the numbers get converted to text ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; ## [9] &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;16&quot; ## [17] &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; ## [25] &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; &quot;31&quot; &quot;32&quot; ## [33] &quot;33&quot; &quot;34&quot; &quot;35&quot; &quot;36&quot; &quot;37&quot; &quot;38&quot; &quot;39&quot; &quot;40&quot; ## [41] &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; &quot;45&quot; &quot;46&quot; &quot;47&quot; &quot;48&quot; ## [49] &quot;49&quot; &quot;50&quot; &quot;fifty&quot; &quot;words&quot; Make a data.frame using the two vectors fiftywords &lt;- data.frame(fifty, words) What happened to your text vector? # It got recycled 25 times Make a list containing some of the variables you’ve created so far. list(fifty, words, fiftywords) ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ## [24] 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ## [47] 47 48 49 50 ## ## [[2]] ## [1] &quot;fifty&quot; &quot;words&quot; ## ## [[3]] ## fifty words ## 1 1 fifty ## 2 2 words ## 3 3 fifty ## 4 4 words ## 5 5 fifty ## 6 6 words ## 7 7 fifty ## 8 8 words ## 9 9 fifty ## 10 10 words ## 11 11 fifty ## 12 12 words ## 13 13 fifty ## 14 14 words ## 15 15 fifty ## 16 16 words ## 17 17 fifty ## 18 18 words ## 19 19 fifty ## 20 20 words ## 21 21 fifty ## 22 22 words ## 23 23 fifty ## 24 24 words ## 25 25 fifty ## 26 26 words ## 27 27 fifty ## 28 28 words ## 29 29 fifty ## 30 30 words ## 31 31 fifty ## 32 32 words ## 33 33 fifty ## 34 34 words ## 35 35 fifty ## 36 36 words ## 37 37 fifty ## 38 38 words ## 39 39 fifty ## 40 40 words ## 41 41 fifty ## 42 42 words ## 43 43 fifty ## 44 44 words ## 45 45 fifty ## 46 46 words ## 47 47 fifty ## 48 48 words ## 49 49 fifty ## 50 50 words Return the some rows from the iris dataset head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa A.4 Data manipulation exercises Select all LETTERS before “X”; LETTERS[LETTERS &lt; &quot;X&quot;] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; ## [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; Select the first 5 rows from the built-in data.frame iris; iris[1:5, ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa Select the first 2 columns from iris; head(iris[, 1:2]) ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 ## 6 5.4 3.9 Select the column Sepal.Length from iris by name. head(iris[, &quot;Sepal.Length&quot;]) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 Select rows from the iris data.frame where the Sepal.Length is greater than 5.8cm; head(iris[iris$Sepal.Length &gt; 5.8, ]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 51 7.0 3.2 4.7 1.4 versicolor ## 52 6.4 3.2 4.5 1.5 versicolor ## 53 6.9 3.1 4.9 1.5 versicolor ## 55 6.5 2.8 4.6 1.5 versicolor ## 57 6.3 3.3 4.7 1.6 versicolor ## 59 6.6 2.9 4.6 1.3 versicolor Select rows from the iris data.frame where the Sepal.Width is below the average for that column. head(iris[iris$Sepal.Width &lt; mean(iris$Sepal.Width), ]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 2 4.9 3.0 1.4 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 13 4.8 3.0 1.4 0.1 setosa ## 14 4.3 3.0 1.1 0.1 setosa ## 26 5.0 3.0 1.6 0.2 setosa ## 39 4.4 3.0 1.3 0.2 setosa Select everything from iris except the Species column; head(iris[, -5]) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 Create a copy of the iris data that just contains the first 100 rows and call it myIris; myIris &lt;- iris[1:100, ] Update the species column to the value “Unknown” in myIris; myIris$Species &lt;- &quot;Unknown&quot; Delete rows from myIris where the sepal length is greater than 5.5. myIris &lt;- myIris[myIris$Sepal.Length &lt;= 5.5, ] "],
["software.html", "B Software B.1 R B.2 RStudio B.3 Suggested packages", " B Software B.1 R B.2 RStudio B.3 Suggested packages The following are used in example content. You do not need these to work through the exercises. tidyverse caret datasauRus install.packages(c(&quot;tidyverse&quot;, &quot;caret&quot;, &quot;datasauRus&quot;)) "]
]

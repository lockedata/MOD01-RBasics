[
["r-objects.html", "3 R objects 3.1 Storing values 3.2 Vectors 3.3 Getting information about vectors 3.4 Calculations on multiple vectors 3.5 data.frames 3.6 Importing data.frames 3.7 Getting information about data.frames 3.8 Lists 3.9 Getting information about lists 3.10 Other object types 3.11 Useful functions 3.12 R objects exercises", " 3 R objects So far we’ve just worked with some single values to get to grips with how some of the various operations work. Of course, we rarely work with a single value! If we did, we could just use a calculator. This section helps you get to grips with some different ways of storing data and how to manipulate your datasets in the “traditional” way. This is useful because you can understand a lot of code written in the past and equips you to understand the material in the next book, which focusses on data manipulation of tabular data. 3.1 Storing values When we were performing operations, we got some values output to the console. One of the key principles in writing code is Don’t Repeat Yourself (DRY) so we need to know how we can avoid repeating ourself in R. One of the ways you can do that is to store a value for use later. In R, we can store values by assigning them a name. This makes a variable or object. We can do this with a few different operators, but the traditional operator is a &lt;-1. The format for assigning a value is nameofthing &lt;- value. my_variable &lt;- 5 + 3 my_variable &gt; 6 &amp; my_variable &lt; 10 ## [1] TRUE Valid names for a variable include upper case letters, lower case letters, numbers anywhere but the beginning, periods (.), and hyphens (_). There are a number of different competing conventions for how you name variables. The most common conventions are shown below. I have no strong feelings for any system and only ask that at minimum you’re pick one and stick with it within a single script. Whatever you do, don’t forget names are case sensitive! myfirstvariable &lt;- 1 myFirstVariable &lt;- 1 MyFirstVariable &lt;- 1 my_first_variable &lt;- 1 my.first.variable &lt;- 1 You can create names breaking the rules governing valid names by placing the rule breaking name between two backticks (`). I don’t recommend you do this with variables you’ll create, but you’ll often end up with names that break conventions when importing data, especially when you import from spreadsheets. `valid name`&lt;- 1 `2017` &lt;- 1 ` ` &lt;- 1 `$$$` &lt;- 1 Variables you store get stored in-memory. This means they’ll hang around whilst R is open and will be gone after that. You can see variables you’ve created RStudio will by default save your variables for you so that next time you open it up, your variables are stored. RStudio saving your variables is a blessing because you don’t have to worry about keeping RStudio open the all time. It’s also a pretty major curse because you’ll inevitably create something at some point through the console or an Untitled R file and then lose that bit of code. Now when you’re script runs in a fresh session it’ll fail. You’ll risk tearing your hair out and worse as you go through the pain of debugging this. I recommend you get in the habit early of not working with your session being saved. Turn it off in Tools &gt; Global Options, untick “Restore .RData into workspace at startup” If you need to manage what’s been stored you can list objects with ls() and remove them with rm(). If you want to remove everything you can usels() inside rm(). Alternatively, you can use the broom symbol in the Environment tab in RStudio. today&lt;-Sys.Date() rm(&quot;today&quot;) ls() ## [1] &quot; &quot; &quot;$$$&quot; &quot;2017&quot; ## [4] &quot;my.first.variable&quot; &quot;my_first_variable&quot; &quot;my_variable&quot; ## [7] &quot;myfirstvariable&quot; &quot;myFirstVariable&quot; &quot;MyFirstVariable&quot; ## [10] &quot;valid name&quot; rm(list=ls()) 3.2 Vectors A vector is a collection of values that hold the same datatype. It is one-dimensional in that none of the elements in the collection correspond to other values like they might in a table of values. A single value is actually a vector of length 1. When I introduced the colon (:) as a means on generating a sequence, we were in fact generating a vector where each element was a number in the sequence. The vector has a length as long as the number of values generated by the sequence. -1:1 ## [1] -1 0 1 Another way of producing a vector is to use the combine function (c()). This is great for combining a number of disparate character strings into a vector. c(&quot;red&quot;,&quot;yellow&quot;,&quot;blue&quot;) ## [1] &quot;red&quot; &quot;yellow&quot; &quot;blue&quot; A single value is a still a vector. What we see when we use the c() function is that we’re combining vectors. As a result we can also use it on longer vectors too. c(1:3, 2:1, 5:8) ## [1] 1 2 3 2 1 5 6 7 8 When we combine values into a single vector, R will change everything to the same datatype using some conversions. c(1, FALSE) ## [1] 1 0 c(1, &quot;FALSE&quot;) ## [1] &quot;1&quot; &quot;FALSE&quot; This implicit conversion is something to be careful of and can really screw up your results! If in doubt, check the datatype with the class() function, or look for the vector in your global environment and see what the datatype is from there. We can also give names to values being included in a vector. c(first=&quot;Steph&quot;, last=&quot;Locke&quot;) ## first last ## &quot;Steph&quot; &quot;Locke&quot; 3.3 Getting information about vectors Our class() function will still work with a vector with a length greater than 1 to get you it’s datatype. class(1:10) ## [1] &quot;integer&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; ## [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; class(LETTERS) ## [1] &quot;character&quot; We can use the length() function to find out the number of elements in a vector. length(pi) ## [1] 1 length(LETTERS) ## [1] 26 To extract the names of values in a vector, we can use the names() function. steph&lt;-c(Steph=&quot;forename&quot;, Locke=&quot;surname&quot;) names(steph) ## [1] &quot;Steph&quot; &quot;Locke&quot; 3.4 Calculations on multiple vectors When we perform calculations on two vectors, R will try to perform the operation for each set of elements. This is an element-wise calculation methodology. In SQL, it’s equivalent to where you might write colA*colB and you’ll get the answer calculated for every row in the table. In Excel, it’s equivalent to a Fill Down of multiplying two values on the same row. Let’s looks at how this works in practice in R. We have two vectors, each containing two elements. vecA &lt;- 1:2 vecB &lt;- 2:3 If we want to multiply the two vectors by each other, R will match each element in the first vector with it’s counterpart in the second and multiply the two values together to make a new element. vecA*vecB ## [1] 2 6 We can also do this with vectors of different lengths to a certain extent. The most common scenario is operating on a vector by doing something with a single value. A single value is a vector of length 1. When R gets a request to do something with a vector of length X and a vector of length 1, it will basically repeat the vector of length 1 X times to make two vectors the same length. It wil then perform the calculation element-wise. vecA*3 ## [1] 3 6 You can also use this functionality of making a vector the same length as another, known as recycling, work for other mis-matched vector sizes. The only rule is the one of the vector lengths must divide cleanly by the other. Two vectors of the same length divide by the other’s length exactly one time and won’t need to recycle. A vector of length one always cleanly divides any other vector’s length and so will be recycled. A vector of length 2, will divide any vector with an even length and so will be recycled in those cases, but it cannot recycle cleanly for odd length vectors. 1:10 * 2 ## [1] 2 4 6 8 10 12 14 16 18 20 1:10 * 2:3 ## [1] 2 6 6 12 10 18 14 24 18 30 1:10 * 2:4 ## Warning in 1:10 * 2:4: longer object length is not a multiple of shorter ## object length ## [1] 2 6 12 8 15 24 14 24 36 20 Vector recycling is useful and dangerous – it can help you make elegant code or give you unexpected results. Especially when starting out, I recommend you make your vectors either the same length or length 1. 3.5 data.frames A data.frame is table similar to what we’re used to working with in most data analysis tools. It will contain a number of rows with columns containing different pieces of information. Each column in a data.frame has a datatype but it does not have to the same datatype as the other columns. We can construct a data.frame from individual vectors via the data.frame() function. data.frame(a=1:2,b=c(&quot;blue&quot;,&quot;red&quot;)) ## a b ## 1 1 blue ## 2 2 red You can also give row names to the rows you end up making, however, I recommend you add these in as a column instead. data.frame(a=1:2,b=c(&quot;blue&quot;,&quot;red&quot;),row.names = c(&quot;First&quot;,&quot;Second&quot;)) ## a b ## First 1 blue ## Second 2 red Throughout many of the examples, I’ll use the example datasets that are available by default in R. View(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa The View() function is specific to RStudio and provides a nice visual grid view of a data.framae and it allows you to search and sort the table for some initial exploration. More commonly, we’ll import data an outside source. 3.6 Importing data.frames You can import data via code, but one of the eassiest ways of getting started is to load data via RStudio and have it generate the code for you. To import data, go to the Environment tab and select Import Dataset. Select the relevant type of data you want to import. Browse to the file you want to upload. Keeping data in the project directory is ideal as it keeps everything in one place and makes import code easier to read. You can tweak the advanced settings and then select the Import button to load the data directly into memory. Alternatively, you can copy the code it generated for you and paste it into a script. By doing this copy and pasting, you will make the import reproducible. Next time you need to load the data you can just run the code, instead of using the interface again. 3.6.1 Error!! If you were tying to do this import and you have a fresh installation of R and RStudio, you probably got an error when you tried to load a file because you don’t have some of the required functionality that RStudio expects you to have. It will tell you the name of the thing you’re missing. In my case - I’m missing the package “readr”. To make this available to us, we go to the Packages tab and then: select Install type “readr” select the Install button accept any popups for things like restarting R 3.7 Getting information about data.frames Our data.frames are composites, they are the result of combining a number of vectors with different data types. As a consequence, when we run our class() function, it tells us an object is a data.frame and no longer returns the underlying datatype. class(iris) ## [1] &quot;data.frame&quot; You do not get the number of rows in a data.frame when you run the length() function, instead you get the number of columns2. Alternatively, you can run the more clearly named ncol() function to return the number of columns in a data.frame. length(iris) ## [1] 5 ncol(iris) ## [1] 5 You can get the number of rows via the nrow() function. nrow(iris) ## [1] 150 Similarly to length(), the names() function when applied to data.frame’s only works on the columns, so you can use it to get column names. A clearer alternative is to use the colnames() function. You can use rownames() to get names for rows, if they exist. mydf &lt;- data.frame(a=1:2, b=c(&quot;blue&quot;,&quot;red&quot;), row.names = c(&quot;First&quot;,&quot;Second&quot;)) names(mydf) ## [1] &quot;a&quot; &quot;b&quot; colnames(mydf) ## [1] &quot;a&quot; &quot;b&quot; rownames(mydf) ## [1] &quot;First&quot; &quot;Second&quot; 3.8 Lists Lists are your catch-all object. An element in a list can be any object, including a list! You’ll usually find yourself using a list when you’re receiving some nested data (like from some API response) or when you want to bundle multiple connected pieces of information together. Most functionality for building statistical models in R will return a list object holding things like the model coefficients, key statistics, and fitted values. You can create lists with the list() function and like with our other objects you can have named and unnamed elements. mylist&lt;-list(a=1:3, LETTERS) mylist ## $a ## [1] 1 2 3 ## ## [[2]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; ## [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; 3.9 Getting information about lists The length() function will tell you how many elements there are in a list. length(mylist) ## [1] 2 names() lets you get the element names and returns a blank (&quot;&quot;) where no name was provided. names(mylist) ## [1] &quot;a&quot; &quot;&quot; 3.10 Other object types There a number of other object types in R. They won’t be covered in detail in this book, because they tend to be used by a small fraction of R users. A matrix is two-dimensional object that can only one datatype. An array is a multi-dimensional object that can contain only one datatype. A table object is similar to a matrix but is created by producing a contingency table. In R, developers can also create other object types specific to their requirements. People use this to create geospatial objects and more. 3.11 Useful functions Whatever the object type, there some functions that come in handy for You get the contents of any object by writing it’s name. mylist ## $a ## [1] 1 2 3 ## ## [[2]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; ## [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; However, if you’re working with a lot of data, you probably don’t want to fill up your console that way. R has two functions, head() and tail(), which allow you to see values from beginning or end of an object. head(LETTERS) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; tail(LETTERS) ## [1] &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; If you want to examine an R object, you can use the str() function to get the structure of the object. str(mylist) ## List of 2 ## $ a: int [1:3] 1 2 3 ## $ : chr [1:26] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... 3.12 R objects exercises See what’s in the variable letters; Write a check to see if “A” is present in letters; Find out which values in the sequence 1 to 10 are greater than or equal to 3 and less than 7. Make a vector containing the numbers 1 to 50; Make a vector containing two words; What happens when you combine these two vectors? Make a data.frame using the two vectors What happened to your text vector? Make a list containing some of the variables you’ve created so far. Return the some rows from the iris dataset Other valid values are the equals symbol = and you can also do a right-handed assignment with -&gt;↩ This is because a data.frame is actually just a prettily printed list and each column in an element in said list and length returns the number of elements.↩ "]
]

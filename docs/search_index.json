[
["index.html", "R fundamentals Introduction", " R fundamentals Locke Data Introduction Welcome to the first book in Locke Data’s series of books on R and data science! This first book introduces R, helps you get the most out of the RStudio programming environment, and teaches basic operations in R. Basic doesn’t mean funky alas so if you want to skip ahead to the funky bits, you can get the next book. This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. "],
["prerequisites.html", "Prerequisites", " Prerequisites This book assumes no prior knowledge of programming. Basic use of calculators and Excel is assumed. This is so that if we say things like (5*5)-2 you know that I mean something like “subtract two from the result of five multiplied by five”. If you’re not sure about this type of thing you might struggle. You should be able to install (or get installed) R, RStudio, and, if on Windows, RTools. You can code online at r-fiddle.org but this might be unreliable. The instructions for installation in "],
["steph-locke.html", "Steph Locke", " Steph Locke "],
["locke-data.html", "Locke Data", " Locke Data Locke Data is a consultancy that helps people and organisations get started with data science. We offer training, advice, and technical leadership to make sure things go more smoothly. Find out more about us at itsalocke.com. "],
["conventions.html", "Conventions", " Conventions Throughout this book various conventions will be used. In terms of basic formatting: This is standard text. This is code or a symbol Keyboard Key This is a book about coding, so expect code blocks. Code blocks will typically look like. Note the result underneath - this is the result of executing the code block. &quot;this is a code block&quot; ## [1] &quot;this is a code block&quot; There will also be callouts throughout the book. Some are for information, some expect you to do things. This is a tip about what I’ve just said. This is kind of like a tip but is for those break-the-glass, moments where things have gone very very wrong and you need to escape. This is something I recommend you do as you’re reading. This let’s you know that something I mention briefly will be followed up later, whether in this book or a later one. If this is still here, someone at Locke Data needs to do something! "],
["about-r.html", "1 About R 1.1 Key points to know about R", " 1 About R R is an open source language released in 2001 that’s ideal for data wrangling and data science. R has a long lineage - it was written to re-implement the language S. S was a commerical language written in the mid-1970s to enable statistical and graphical processing. Indeed much code written in S can still run today, a phenomenal feat! If you ever look at how R and wonder “Why on Earth does it work like that?”, the usual answer is “Because S”.1 plot(rnorm(10)) The last paragraph might lead you to ponder why R is in use today and why the popularity is growing? R is a vibrant ecosystem that enables people to extend, enhance, and replace itself. There are many paradigms in R to facilitate object-oriented programming, functional programming, and more. If you can write something in R, C++, FORTRAN2, Python, or JavaScript you can extend R. There are currently more than eleven thousand extensions to R a.k.a. packages in the core ecosystem (CRAN) and two and a half thousand packages in the genomics ecosystem (BioConductor). We’re also seeing emerging ecosystems and paradigms within CRAN. The tidyverse is one such ecosystem, focussed primarily on analysing tabular data, and it will be used in future works extensively. 1.1 Key points to know about R R works in-memory which means that the processing is fast but the amount of data you can process is limited to how much RAM your data takes up and how much your computations will require. R is not multi-threaded by default. R works on a single CPU core and parallelisation requires additional packages and often additional coding. R is quirky! R works a bit like lots of languages which makes it easy to pick up in some respects, but because of the S compatability it’s actually pretty darn old and a result, really odd in places. Coding R will give you the typical gotcha’s and add another, case sensitivity. R is (un)fortunately a language where “Red” and “red” are different and this also extends to variable and function names. As a consequence, the most common errors you’ll find when writing code in R are: Mis-placed or missing commas Mis-placed or missing brackets Incorrect case used when typing With so many packages available to extend R with, the answer to “how do I write this?” is usually “there’s a package for that”. We’ll look at finding packages later in this book. Read Rbitrary for more info↩6.2 ComparisonThe next important thing to know about is how to write comparisons.6.2.1 Common operatorsThe less thans and greater thans are symbols that are in pretty much every language for comparisons, but the test to see if two values are the same or not can often vary across languages.2 &lt; 3## [1] TRUE3 &gt; 2## [1] TRUE2 &gt;= 2## [1] TRUE2 &lt;= 2## [1] TRUEIn R, you test if two values are exactly the same with == and you test if they’re different with !=.2 == 2## [1] TRUE2 != 2## [1] FALSEYou can test if a value is present in a list of acceptable values using the %in% operator. This may seem a little trivial right now, but once we start covering more than one value at a time, it’ll start showing it’s uses for strings.2 %in% 1:3## [1] TRUE6.2.2 A gotchaTesting for equality can get a little weird with R because it uses a different way of storing numbers than we would expect. It doesn’t store numbers quite as precisely as we expect - somewhere at the very end of a large number of decimal places, the value can be rounded incorrectly. It doesn’t make a difference to most of our calculations but it will often hit when you’re comparing two decimal values.Let’s see an example.Both these calculation return what we think of as 0.20.5 - 0.3## [1] 0.20.6 - 0.4## [1] 0.2Indeed, if we test 0.2 is the same as 0.2 we get a TRUE which matches our expectations.0.2 == 0.2## [1] TRUEBut, when we perform two calculations, even though they come out to the same value to us, there’s a little bit of imprecision in how they’re stored that stops from being exactly the same number.(0.6 - 0.4) == (0.5 - 0.3)## [1] FALSETo avoid this issue, if you’re comparing decimal values that result from calculations it is better to use the all.equal() function. all.equal() adds a tolerance to the comparison which means the very subtle imprecision is ignored. The default tolerance is 1.510^{-8}, in other words the imprecision is very, very small.all.equal(0.6 - 0.4 , 0.5 - 0.3)## [1] TRUE6.2.3 SummaryActionOperatorExampleLess than&lt;5 &lt; 5 = FALSELess than or equal to&lt;=5 &lt;= 5 = TRUEGreater than&gt;5 &gt; 5 = FALSEGreater than or equal to&gt;=5 &gt;= 5 = TRUEExactly equal==(0.5 - 0.3) == (0.3 - 0.1) is FALSE, 2 == 2 is TRUENot equal!=(0.5 - 0.3) != (0.3 - 0.1) is TRUE, 2 != 2 is FALSEEqualall.equal()all.equal(0.5 - 0.3,0.3 - 0.1) is TRUEIn%in%&quot;Red&quot; %in% c(&quot;Blue&quot;,&quot;Red&quot;) is TRUE6.3 LogicOnce we can do a single check, we inevitably want to do multiple checks at the same time.To combine multiple checks, we can use logical operators.6.3.1 Common operatorsThe ampersand (&amp;) allows us to combine two checks to do an AND check which is “are both things true”.TRUE &amp; TRUE## [1] TRUETRUE &amp; FALSE## [1] FALSEFALSE &amp; FALSE## [1] FALSE(2 &lt; 3) &amp; (4 == 4)## [1] TRUE(2 &lt; 3) &amp; (4 != 4)## [1] FALSEThe pipe / bar (|)17 allows us to do an OR check which is “are either of these things true”.TRUE | TRUE## [1] TRUETRUE | FALSE## [1] TRUEFALSE | FALSE## [1] FALSE(2 &lt; 3) | (4 == 4)## [1] TRUE(2 &lt; 3) | (4 != 4)## [1] TRUEThe exclamation point (!) allows us to a perform a NOT by negating or swapping a check’s result. This allows you say things like “is this check true and that check not true”.TRUE &amp; TRUE## [1] TRUETRUE &amp; !FALSE## [1] TRUE!FALSE &amp; !FALSE## [1] TRUE(2 &lt; 3) &amp; (4 == 4)## [1] TRUE(2 &lt; 3) &amp; !(4 != 4)## [1] TRUE6.3.2 Other operatorsLess commonly, there other logical checks you might to perform.We can do an XOR, where one and only one of two values being checked is true.xor(TRUE, FALSE)## [1] TRUExor(TRUE, TRUE)## [1] FALSExor(FALSE, FALSE)## [1] FALSEWe’ll see how this works in the next section, but when we use our logical operators it will do the comparison for every row. Sometimes we might be performing comparisons for many values but we need to to guarantee we get just one value back. We can use variants or AND and ORs called bitwise comparisons to achieve this. Use these with care as the results can be a little bit weird!TRUE &amp;&amp; TRUE## [1] TRUETRUE &amp;&amp; FALSE## [1] FALSETRUE || TRUE## [1] TRUETRUE || FALSE## [1] TRUE1:2&gt;1## [1] FALSE TRUE2:3&gt;1## [1] TRUE TRUE1:2&gt;1 &amp;&amp; 2:3&gt;1## [1] FALSE6.3.3 SummaryWe can produce sophisticated checks from a few simple building blocks. This will come in very handy down the line when doing things like filtering datasets or creating new fields in your data.ActionOperatorExampleNot!!TRUE is FALSEAnd&amp;TRUE &amp; FALSE is FALSE, c(TRUE,TRUE) &amp; c(FALSE,TRUE) is FALSE, TRUEOr|TRUE | FALSE is TRUE, c(TRUE,FALSE) | c(FALSE,FALSE) is TRUE, FALSEXorxor()xor(TRUE,FALSE) is TRUEBitwise And&amp;&amp;c(TRUE,TRUE) &amp;&amp; c(FALSE,TRUE) is FALSEBitwise Or||c(TRUE,FALSE) || c(FALSE,FALSE) is TRUE6.4 SummaryThis basic operations section has taught how to manipulate values and consstruct comparisons. These are important building blocks in ddata analysis, and whilst we’ve been working with only a single value at a time, in the next section we’ll see how it works with more data.ActionOperatorExampleSubtract-5 - 4 = 1Add+5 + 4 = 9Multiply*5 * 4 = 20Divide/5 / 4 = 1.25Raise to the power^5 ^ 4 = 625Less than&lt;5 &lt; 5 = FALSELess than or equal to&lt;=5 &lt;= 5 = TRUEGreater than&gt;5 &gt; 5 = FALSEGreater than or equal to&gt;=5 &gt;= 5 = TRUEExactly equal==(0.5 - 0.3) == (0.3 - 0.1) is FALSE, 2 == 2 is TRUENot equal!=(0.5 - 0.3) != (0.3 - 0.1) is TRUE, 2 != 2 is FALSEEqualall.equal()all.equal(0.5 - 0.3,0.3 - 0.1) is TRUEIn%in%&quot;Red&quot; %in% c(&quot;Blue&quot;,&quot;Red&quot;) is TRUENot!!TRUE is FALSEAnd&amp;TRUE &amp; FALSE is FALSE, c(TRUE,TRUE) &amp; c(FALSE,TRUE) is FALSE, TRUEOr|TRUE | FALSE is TRUE, c(TRUE,FALSE) | c(FALSE,FALSE) is TRUE, FALSEXorxor()xor(TRUE,FALSE) is TRUEBitwise And&amp;&amp;c(TRUE,TRUE) &amp;&amp; c(FALSE,TRUE) is FALSEBitwise Or||c(TRUE,FALSE) || c(FALSE,FALSE) is TRUE6.5 Basic Operations ExercisesWhat is the result of pi^2?Is pi greater than 3?Construct a statement to check if 5 is both greater than 3 and less than or equal to 6What are the results if you check to see if a sequence of 1 to 5 is less than or equal to 3?7 R objects7.1 Other key syntaxActionOperatorExampleCreate / update a variable&lt;-a &lt;- 10Create / update a variable=a = 10Create / update a variable-&gt;10 -&gt; aComment## This is my commentHelp??data.tableIdentifier``1`&lt;-27.2 In-memoryAll variables / objects will get stored in-memory;You need memory for operations too.FunctionPurposels()List what’s in-memoryrm()Remove things from memory7.3 VectorsA 1D object containing a single type of dataFunctionPurposec()Combine values into a vector:Generate a sequence1:3## [1] 1 2 3c(&quot;red&quot;,&quot;blue&quot;,&quot;orange&quot;)## [1] &quot;red&quot; &quot;blue&quot; &quot;orange&quot;7.3.1 ExercisesSee what’s in the variable LETTERS;Write a check to see if “a” is present in LETTERS;Find out which values in the sequence 1 to 10 are greater than or equal to 3 and less than 7.Make a vector containing the numbers 1 to 50;Make a vector containing two words;What happens when you combine these two vectors?7.4 Data.framesA 2D object containing multiple classes of dataFunctionPurposedata.frame()Construct a data.framedata.frame(a=1:2,b=c(&quot;blue&quot;,&quot;red&quot;))## a b## 1 1 blue## 2 2 red7.4.1 ExercisesMake a data.frame the two vectors you created in the vectors section;What happened to your text vector?7.5 ListsAn object containing multiple types of objectsFunctionPurposelist()Construct a listlist(a=1:2, b=c(&quot;blue&quot;,&quot;red&quot;), df=data.frame(a=1:2,b=c(&quot;blue&quot;,&quot;red&quot;)))## $a## [1] 1 2## ## $b## [1] &quot;blue&quot; &quot;red&quot; ## ## $df## a b## 1 1 blue## 2 2 red7.5.1 ExercisesMake a list containing some of the variables you’ve created so far.7.6 OthersMatrix A 2D object of one data typeArray A nD object of one data type8 R data manipulation basics8.1 Grid referencesR works in a grid reference system like [row , column]. So…For a 1D vector, there’s just one position i.e. vector[ row ]For a data.frame, there’s two positions i.e. data.frame[ row , column ]8.2 Grid referencesValid values include:Positive values or ranges;Negative values or ranges;Boolean ranges;Names or vectors of names.8.3 Grid referencing8.4 Grid referencing vectorsLETTERS[1]## [1] &quot;A&quot;LETTERS[1:3]## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot;LETTERS[-1]## [1] &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot;## [18] &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot;LETTERS[-13:-1]## [1] &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot;LETTERS[c(TRUE,FALSE)]## [1] &quot;A&quot; &quot;C&quot; &quot;E&quot; &quot;G&quot; &quot;I&quot; &quot;K&quot; &quot;M&quot; &quot;O&quot; &quot;Q&quot; &quot;S&quot; &quot;U&quot; &quot;W&quot; &quot;Y&quot;8.5 Grid referencing data.framesmyDF&lt;-data.frame(a=1:3, b=2:4, c=3:5)myDF[1,]## a b c## 1 1 2 3myDF[,-1]## b c## 1 2 3## 2 3 4## 3 4 5myDF[1,1]## [1] 1myDF[1:2,]## a b c## 1 1 2 3## 2 2 3 4myDF[c(TRUE,FALSE,TRUE),]## a b c## 1 1 2 3## 3 3 4 5myDF[,&quot;a&quot;]## [1] 1 2 38.5.1 ExercisesSelect all letters before “x”;Select the first 5 rows from the built-in data.frame iris;Select the first 2 columns from iris;Select the column Sepal.Length from iris by name.8.6 Name-checkingRow names can be used to extract values.myNamedVec&lt;-c(&quot;red&quot;=&quot;RED&quot;,&quot;blue&quot;=&quot;BLUE&quot;)myNamedVec[&quot;red&quot;]## red ## &quot;RED&quot;Column names can also be referenced.colnames( iris[,&quot;Species&quot;] )## NULLcolnames( iris$Species )## NULLcolnames( iris[,c(&quot;Sepal.Width&quot;,&quot;Species&quot;)] )## [1] &quot;Sepal.Width&quot; &quot;Species&quot;8.7 Self-referencingUseful for creating booleans, you can create a vector and use this inside your grid reference system.LETTERS[LETTERS&lt;&quot;T&quot;]## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot;## [18] &quot;R&quot; &quot;S&quot;myDF[myDF$a&lt;=2,]## a b c## 1 1 2 3## 2 2 3 48.7.1 ExercisesGet all letters that occur after “g”;Select rows from the iris data.frame where the Sepal.Length is greater than 5.8cm;Select rows from the iris data.frame where the Sepal.Width is below the average for that column.8.8 UpdatingYou can update part or all of simple objects by assigning new values against a grid-reference.myVec&lt;-LETTERS[1:3]myVec[1]&lt;-&quot;Z&quot;myVec## [1] &quot;Z&quot; &quot;B&quot; &quot;C&quot;myDF[1, ]&lt;- 1:3myDF## a b c## 1 1 2 3## 2 2 3 4## 3 3 4 58.9 DeletingYou can use the selections to remove valuesmyVec&lt;-myVec[-2]myVec## [1] &quot;Z&quot; &quot;C&quot;myDF&lt;-myDF[-3,-1]myDF## b c## 1 2 3## 2 3 48.9.1 ExercisesSelect everything from iris except the Species column;Create a copy of the iris data that just contains the first 100 rows and call it myIris;Update the species column to the value “Unknown” in myIris;Delete rows from myIris where the sepal length is greater than 5.5.9 R functions9.1 Using a functionA function does some computation on an object. The use of a function consists of:A function’s name;Parentheses;0 or more inputs.Sys.Date()## [1] &quot;2017-08-09&quot;sum(1:3)## [1] 69.2 Function argumentsFunctions can have:0 arguments e.g. Sys.Date();all mandatory arguments e.g. length();optional arguments e.g. sum();arguments used out of position by using their names e.g. `rnorm(mean=1, n=10).9.3 Common functionsAreaFunctionsMetadataclass, mode,length, names, nrow, ncolMeasuresmean, median, mode, range, sum, cumsumStringsgrep, gsub, substr, trim, toupper, pasteFileslist.dirs, list.files, file.exists9.4 Finding functionsFind functions by:Using code-completionUsing help-pagesUsing ?meanUsing ??meanUsing apropos(&quot;mean&quot;)9.5 Seeing how functions workYou can examine how many functions work by just typing their name without any parentheses.Sys.Date## function () ## as.Date(as.POSIXlt(Sys.time()))## &lt;bytecode: 0x000000001af284f8&gt;## &lt;environment: namespace:base&gt;9.6 ExercisesFind a function that involves Normal distributions;Find some functions operate on files.10 R packages10.1 What is a package?An R package is a bundle of functions and/or datasets. It extends the capabilities that the “base” and “recommended” R packages have. This gives us the ability to do a lot more.10.2 Using packagesInstall a package with install.packages();Load a package with library();See what’s in a package / reference it without loading packagename::function();See what’s ina package but not exposed to the public packagename:::function().10.3 Useful packagesAreaPackagesData manipulationdplyr, data.table,tidyr, stringr, forcatsData visualisationggplot2,leaflet,ggraphStatisticstidytext, caret, broomI/ORODBC, DBI, data.table, readxlWebrvest, httr, urltoolsOutputsrmarkdown, revealjs, shiny, flexdashboards10.4 Finding packages10.5 Package documentationPackages should have documentation at the following levels:Function;Workflow via vignettes;NEWS;DESCRIPTION;READMEs on github.10.6 ExercisesLoad the library dplyr;Browse dplyr’s help pages;Read a dplyr introductory vignette;Read dplyr’s README.A AnswersA.1 R Data Types ExercisesConvert TRUE to an integeras.integer(TRUE)## [1] 1What is the datatype of the value returned by Sys.time()?class(Sys.time())## [1] &quot;POSIXct&quot; &quot;POSIXt&quot;What is the datatype of the value returned by Sys.timezone()?class(Sys.timezone())## [1] &quot;character&quot;Make this quote into an R string &gt; “Do you think this is a game?”, he said. “No I think Jenga’s a game”, Archer responded.&#39;&quot;Do you think this is a game?&quot;, he said. &quot;No I think Jenga\\&#39;s a game&quot;, Archer responded.&#39;## [1] &quot;\\&quot;Do you think this is a game?\\&quot;, he said. \\&quot;No I think Jenga&#39;s a game\\&quot;, Archer responded.&quot;A.2 Basic Operations ExercisesWhat is the result of pi^2?pi^2## [1] 9.869604Is pi greater than 3?pi&gt;3## [1] TRUEConstruct a statement to check if 5 is both greater than 3 and less than or equal to 6(5 &gt; 3) &amp; (5 &lt;= 6)## [1] TRUEWhat are the results if you check to see if a sequence of 1 to 5 is less than or equal to 3?1:5 &lt;=3## [1] TRUE TRUE TRUE FALSE FALSEB SoftwareB.1 RB.2 RStudioB.3 Suggested packagesThe following are used in example content. You do not need these to work through the exercises.tidyversecaretdatasauRusinstall.packages(c(&quot;tidyverse&quot;,&quot;caret&quot;,&quot;datasauRus&quot;))If you’d like to find out about the assignment operators’ history (&lt;- and -&gt;) and many of the other quirks of R, the article Rbitrary is fantastic and highly irreverent reading.↩ Yes, it still exists and yes, R still relies on it for some key algorithms↩ "],
["why-use-r.html", "2 Why use R? 2.1 Data wrangling 2.2 Data science 2.3 Data visualisation", " 2 Why use R? R as a programming language is brilliant at it’s core competencies – statistics and data visualisation. It’s also a great “glue” language, by which I mean that you can use it perform computations in many different languages and combine the results smoothly. As a result, R enables you to be an effective data wrangler, data scientist, and/or data visualisation practitioner. I wanted to include some code snippets here that exemplify how little is required to do things in R that in other languages or tools used to take me a substantial amount of time. These are illustrative only. Don’t worry if they don’t make much sense. Writing code like these examples will be covered in later books. 2.1 Data wrangling A common issue I’ve had in the past is data from multiple sources that should usually conform to a template but don’t. You end up with a whole stack of files that don’t quite match the template and as a result getting all this data read, combined, and then output somewhere else is often an incredibly difficult task. This snippet of R code performs the following steps: Make functionality from the tidyverse available Identify files needing to be read and combined Read each file individually, whilst applying a column type enforcement Combine the results Combining the results involves matching the columns by name. It will create new columns when it finds additional columns in some of the data and fill in the data. When columns are missing from a dataset it will put NAs in the column. library(tidyverse) list.files(&quot;../data&quot;, full.names = TRUE) %&gt;% # Change &quot;../data&quot; to where your files are map_df(read_csv, col_types=cols(&quot;c&quot;)) %&gt;% bind_rows() -&gt; allmydata nrow(allmydata) ## [1] 105 2.2 Data science An aspect of building models and operationalising them that I’ve always found a bit painful is mapping the pre-processing stages to an operational scenario i.e. how do I apply my pre-processing steps to new data in order to be able to make a prediction? If I want to scale numeric variables, I need to keep some sort of record of the mean and standard deviation in the case of a z-score or the minimum and maximum values if I wanted to do a minmax score. Then I’d have to write something to apply these values to new data in an operational setting, or I’d have to transform my model’s formula to apply the scales on the fly. If I wanted to take it a step further and perform a Principal Component Analysis (PCA) to reduce the amount of features I was working with, I’d have no easy way to do that with the outputs of the R PCA function (princomp()). If I use these principal components in my model, how then to get these for my test data or in production? This snippet of R code performs the following steps: Make functionality from caret available Split my data into training and test samples with the outcome column seperate Build a linear regression model on data scaled using z-scores and turned into principal components Apply the transformations and linear model to get predictions for my test data Instead of using some of the out of the box methods and writing a really long-winded set of code, I can use functionality from the package caret to add a pre-process step to my model develoment. It will then keep these pre-process steps as part of the model and whenever I use the model to make predictions it will first process the data based on the parameters and transformations used on the training data. library(caret) training_data&lt;-mtcars[1:20,-2] training_outcome&lt;-mtcars[1:20,2] test_data&lt;-mtcars[21:32,-2] test_outcome&lt;-mtcars[21:32,2] model&lt;-train(training_data, training_outcome, method=&quot;lm&quot;, preProcess = c(&quot;scale&quot;,&quot;center&quot;,&quot;pca&quot;)) predictions&lt;-predict(model, test_data) 2.3 Data visualisation Data visualisation is an area where R makes it especially difficult to choose just a single example. Instead of showing the many fancy or interactive visualisations you can do in R, I’m instead going to show a part of the workflow. Often times, I need to make a chart and then make that chart for a lot of different datasets. These could be datasets for different customers, samples, or time slices. I can make a chart in R using the package ggplot2 to build a chart of all data. library(ggplot2) library(datasauRus) myPlot&lt;- ggplot(datasaurus_dozen, aes(x,y)) + geom_point() If you want to make a small multiples chart, where the charts are produced in a group, you can use the notion of facetting to make many small charts together. myPlot + facet_wrap(~dataset) If you wanted to produce and save a chart per dataset you can provide updated data to a chart. myPlot %+% simpsons_paradox "],
["using-rstudio.html", "3 Using RStudio 3.1 The console 3.2 Scripts 3.3 Code completion 3.4 Projects", " 3 Using RStudio RStudio is a coding interface to R that makes it easier for you to be productive.3 I’m devoting substantial amounts of this book to your working environment as you can use it to make learning and coding R much easier by taking the time to understand it. The interface will be split up into a top menu and then four panes, although only three may be visible when you first start RStudio. Clean RStudio image, no arrows If you don’t already have it, you should install R and RStudio. If you’re on Windows, it’s also great if you can install Rtools. This gives you the tools to install packages from GitHub later on down the line. 3.1 The console Make a small gif of using the console The (bottom) left hand section is the console. This is where you can execute R code directly. To use the console you type some code alongside the &gt; and hit Enter for the code to be executed. The result will then appear underneath your line of code. Errors, warnings, and messages will also appear in the console. We’ll discuss what these are later in the book Use the console to add two numbers together. If the code you entered wasn’t a complete statement e.g. 1 + 2 +, when you hit Enter, the &gt; will change to a + indicating the code you’re writing will be appended to the line before it. If you want to clean your console and start afresh, hit Ctrl + L to remove whatever has been executed in the console this session. You can use your up and down arrow keys to navigate through previous code you’ve written and executed. If you commit one of the most common coding errors (incorrect amounts or places of brackets and commas) you might end up with an incomplete line and basically lock your console into having thte + symbol at the beginning of each line. If you find yourself stuck with commands just writing and writing and never executing, hit the Esc key to cancel the code and get back to the standard cursor. 3.2 Scripts Create gif of adding a file RStudio allows you to create and work with files containing code. These files give you a way to store and manage your code. The most common file types you might use are R files (.R) and rmarkdown files (.Rmd). rmarkdown files are for generating documents with text and R code interleaved (like this book!) will be covered in a book in future. If you want to get going, checkout the rmarkdown site. You can create one of these files by going to File &gt; New &gt; R Script, the New File button, or with the hotkey combo4 of Ctrl + Shift + N. In an R script you can type code and execute it by hitting Ctrl + Enter5, or selecting the code to run and hitting the Run button. You can execute all the code in a script by hitting Ctrl + Shift + Enter or hitting the Source button. Open a new R script. Write 10*5 in it and execute the code. 3.3 Code completion Create a gif with code completion Whilst writing scripts or typing in our console, we can get help and be more productive by using code completion. Code completion will pick up from what we’ve typed so far and provide a navigable list of suggestions. As we navigate through the list, it’ll provide help text where possible and then it will complete the code we were typing. You access the code completion by hitting Tab whilst typing. Once it’s up you can keep typing to refine the list. Your arrow keys allow you to navigate the list. Hit Esc to back out of the completion capability. Hit Tab to accept whatever value in the list is currently highlighted. On a new line of your script, type a and activate your code completion. Browse the list then cancel out of the list. Overwrite the a with an A and go back into the code completion. Do youu get the same list? What’s different and why? 3.4 Projects So far you’ve seen R as a scratchpad (via the console) and for making an isolated script, but a lot of the time we have to be put data, multiple scripts, documentation and more into a project. An RStudio project is a folder with an extra file. This file can be used to open RStudio, with everything laid out like it was before you closed the project. It can store preferences to allow projects to vary from the way you normally do things.6 At this point in your R coding career, keeping everything where you left off is great. Later on, and especially if you work in anything where reproducibility is valued, you can go to Tools &gt; Project Options … and set the .Rdata fields to “no” so that nothing loads up into memory when you load the project. You can, and should, create a new R project when embarking on a new area of work. To create a project go to File &gt; New Project. Create a gif of making a project This will popup a dialogue that gives you the option to create a brand new project directory, create one from some existing directory you might already have, and creating one with the content of a project in your source control system. Most commonly, you’ll want to create a new directory project. Once selected it’ll then give you the option to create an empty project, a shiny project, or an R package. You’ll normally select the empty projects. Once an option is selected, provide a name and where the project should go. Working with source control, shiny, and creating R packages are all in later books. You can navigate to projects using the project option in the top right corner or in the File section. Create a new project to store the answers to exercises and any code you try out during this book. You don’t have to save the script you were working on before this (unless you want to!) If coding interfaces were game modes, RStudio is Easy mode, Visual Studio is Normal, R-GUI is Hard, vim is Insane, and Emacs is Legacy.↩ I’m a big fan of hotkeys!↩ This hotkey is really nifty as it’ll find the start and end of a block of code and send it all to the console to be executed.↩ Like converting tabs to spaces and the number of spaces characters it should replace with.↩ "],
["useful-resources.html", "4 Useful resources 4.1 The built-in help 4.2 Online 4.3 In-person", " 4 Useful resources Our coding environment RStudio is a great help to us. The code completion makes it easy to find things kind of related to what you’re typing but sometimes you need to do a bit more digging or read a bit more than the snippet of help in the code completion window. 4.1 The built-in help R has pretty great built-in help. You might understand some of it but there’s usually lots of it and most help files give you examples to run. The help files are accessible in the bottom right-hand corner of RStudio. If you want to see some of the built-in help whilst using code completion, you can hit F1. Similarly, you can select a word in script and hit F1 to go to the help. If you don’t have something specific to select from you can go to the help window and use the search facility. If there’s a function that matches what you’re typing that’ll be shortlisted, and you can select it and hit Enter alternatively if you don’t get a match, hitting Enter once you’ve finished typing will enact a fuzzier search. Another way you can get help is by looking at the index of functions available for a given package. You go to the Packages tab and click on the package you’re interested in. This loads up the index for that package and you can then read through what’s available. The help window has some handy navigation features to make it easier to use: In-file search bar for finding words in a help file Navigation arrows for moving between files like Back and Forwards on a web-browser. The New Window button creates a popup with the file so that you make it bigger or put it onto another monitor. 4.2 Online R is a great community that has produced many resources. You can search for previous R questions or ask new ones on the ubiquitous Stack Overflow. If you’re tweeting about R, use the hashtag #rstats. If you want to see what’s happening in the R world, I recommend you follow Mara Averick (@dataandme). RStudio provide a trove of fantastic cheatsheets – including one for being super-productive in RStudio. These are great to download and/or print in order to keep handy as you’re learning. Documentation for R packages is available on CRAN but there a number of online sites that try to iprove the experience, including rdrr.io and rdocumentation.org. R-bloggers is a site consolidating blogs from more than 500 people. It’s a great way to find how-tos. R Weekly is a curated newsletter of key goings on, new packages, and blog posts from the R world. 4.3 In-person The R community as well as having doing a huge amount of tweeting, actually gets together in-person quite a bit. If you’d like to go a meetup, then you should check out this meetup directory. As well as these happenings, you can also check out R-Ladies events. We have a growing number of conferences and you can find ones to attend via the conferences directory. "],
["r-data-types.html", "5 R data types 5.1 Numbers 5.2 Text 5.3 Logical values 5.4 Dates 5.5 Summary 5.6 R Data Types Exercises", " 5 R data types I recommend you add a new file to your R project, save it with a file name referencing this section and try out the code. Add your answers to the exercises and leave yourself some notes by first putting # sign and then typing the note after it. There’s nothing like practice and taking notes for helping you retain info! When we think of different bits of data, some of it might be numbers, text, dates, and more. R has it’s own set of these data types. Before we get into the data types, let’s see how we can get R to tell us what something is. R uses functions to take some inputs and get an output. The function that we can pass a value and get what data type it is as the output if the class() function. class(1) ## [1] &quot;numeric&quot; class(1.1) ## [1] &quot;numeric&quot; class(&quot;1&quot;) ## [1] &quot;character&quot; You can use this class() function if you’re ever unsure what data type something is. This is great for when you’re getting unexpected results! 5.1 Numbers I gloss over a lot of the nuance here as most people will not need it. If you want some of the nuance, read the footnotes. Numbers are split into a few different of types: integers are whole numbers like 1 or 427 numerics are numbers that have a decimal portion associated with them like 1.0 or 3.1338 complex numbers are numbers that make use of the imaginary number i like 4i.9 5.1.1 Converting to numbers The functions as.numeric() and as.integer() allow you to convert something stored as text into a number. These functions will give you some red text as a warning if you attempt to convert something to a number that can’t be safely converted. It will still have performed the conversion though. as.numeric(1) ## [1] 1 as.numeric(1.1) ## [1] 1.1 as.numeric(&quot;1&quot;) ## [1] 1 as.numeric(&quot;r&quot;) ## Warning: NAs introduced by coercion ## [1] NA as.integer(1) ## [1] 1 as.integer(1.1) ## [1] 1 as.integer(&quot;1&quot;) ## [1] 1 as.integer(&quot;r&quot;) ## Warning: NAs introduced by coercion ## [1] NA 5.1.2 Checking numbers You can write checks to see if something is numeric, or an integer, with is.numeric() or is.integer(). is.numeric(1) ## [1] TRUE is.numeric(&quot;1&quot;) ## [1] FALSE is.integer(1) ## [1] FALSE is.integer(1L) # Read the footnote on integers for info on this notation ## [1] TRUE is.integer(&quot;1&quot;) ## [1] FALSE We could also use class() here and inspect the result.10 I’m going to use it here to test the results of a conversion to show you how you can nest functions, which means that the inner-most function gets evaluated and the results are used by the next outer-most function, and so on. class( numeric( &quot;1&quot; ) ) ## [1] &quot;numeric&quot; class( integer( &quot;1&quot; ) ) ## [1] &quot;integer&quot; 5.1.3 Special numbers As well as i to denote imaginary numbers, there are some additional symbols you might encounter or want to use. pi = 3.1415927 Inf represents positive infinity. You’ll often see this if you divide a positive number by zero. -Inf represents negative infinity. You’ll often see this if you divide a negative number by zero. NaN is what happens when you really screw up a calculation and do something like 0/0. 5.2 Text Text, also known as strings, is split up into two core types: characters are text as we typically think of it like “red” factors (and the subtype ordered factors) are a text type where the number of unique values is constrained e.g. the values are selected from a dropdown. It’s not very space-efficient to store everything as text. Factors basically assign each unique value an ID and store the ID. Then when we return the data, it replaces the ID with the text.11 Factors will be covered at length in a later book. The rest of this book will work with characters. In R, you can’t just type some text as it will be construed as an object or function name. To delimit a string you can use speech marks (&quot;) or apostrophes (') at the beginning and end of it to show where it starts and ends. Note you can’t use the two delimiters interchangably e.g. “red’ but you can use them together to enable you have speech marks or apostrophes inside a string e.g. ‘They said “Read this”’ or”It’s mine now“. If you need to have both inside a string you can escape the ones on the iside of a string to say they don’t count as text delimiters. To escape a delimiter you can use a backslash(\\) e.g. “They said &quot;Read this&quot;”. Beware the copy &amp; pasting (C&amp;Ping) of code that isn’t in “pre-formatted” mode. The aesthetically pleasing changing of speechmarks at the beginning and end of some text will screw up your code. If you’re getting weird errors around unexpected symbols or your console queuing up after C&amp;Ping, replace all the speechmarks and see if that fixes things. This can also happen with some types of space characters too. 5.2.1 Converting to strings Converting to characters and factors is the same as working with numbers. You swap “numeric” for “character” or “factor” and you’re done! You’ll see a difference in how these values get displayed. Basic characters are boring - they just print out. Factors look very different. There’s no speech marks and there’s this Levels bit. The Levels tells you what the unique values in the lookup for this datatype are. as.character(1) ## [1] &quot;1&quot; as.character(&quot;1 a&quot;) ## [1] &quot;1 a&quot; as.factor(1) ## [1] 1 ## Levels: 1 as.factor(&quot;1 a&quot;) ## [1] 1 a ## Levels: 1 a 5.2.2 Checking strings We can check text in a similar way to checking numbers. is.character(1) ## [1] FALSE is.character(&quot;1&quot;) ## [1] TRUE is.factor(1) ## [1] FALSE is.factor(&quot;1&quot;) ## [1] FALSE is.factor(as.factor(&quot;1&quot;)) ## [1] TRUE Additionally, the class() function returns the datatype. class(&quot;1&quot;) ## [1] &quot;character&quot; class(as.factor(&quot;1&quot;)) ## [1] &quot;factor&quot; 5.3 Logical values Whilst we’ve been testing our datatypes, we’ve created a lot of logical or boolean values. Booleans values are TRUE and FALSE. R is case-sensitive so these have to be typed uppercase, otherwise it means something different. You can think of the boolean values as 1 and 0, but using these in your code can result in changing your datatype to a number. If things aren’t working as expected make sure to check types as you go along. 5.3.1 Converting to logicals TRUE #cases ## [1] TRUE as.logical(1) ## [1] TRUE as.logical(&quot;TRUE&quot;) ## [1] TRUE as.logical(&quot;true&quot;) ## [1] TRUE FALSE #cases ## [1] FALSE as.logical(0) ## [1] FALSE as.logical(&quot;FALSE&quot;) ## [1] FALSE as.logical(&quot;false&quot;) ## [1] FALSE 5.3.2 Checking logicals There is support for checking if something is of datatype logical. is.logical(1) ## [1] FALSE is.logical(TRUE) ## [1] TRUE is.logical(&quot;TRUE&quot;) ## [1] FALSE class(TRUE) ## [1] &quot;logical&quot; 5.4 Dates Dates are one of the hardest parts of programming! This is a very brief introduction to dates and they will not be covered further in this book. Expect a later book to dedicate a lot of page space to date handling. Dates in R split into: dates do not have any time component POSIX datetimes POSIXct is an integer based storage method POSIXlt is a component based storage method You might be looking at the two POSIX times and thinking to yourself “ZOMG how am I meant to choose?”. Most people use the POSIXct format12, which is the default for many of R’s functions. 5.4.1 Converting to dates You can convert to datetime’s with as.Date(),as.POSIXct(), and as.POSIXlt(). Ideally, you’ll provide a string with the date(time) in ISO8601 formats e.g. “YYYY-MM-DD hh:ss”. If not, you’ll want to read up on the datetime format specifications for R. as.Date(&quot;2017-12-31&quot;) ## [1] &quot;2017-12-31&quot; as.POSIXct(&quot;2017-12-31&quot;) ## [1] &quot;2017-12-31 GMT&quot; as.POSIXlt(&quot;2017-12-31&quot;) ## [1] &quot;2017-12-31 GMT&quot; as.Date(&quot;2017-12-31 23:59&quot;) ## [1] &quot;2017-12-31&quot; as.POSIXct(&quot;2017-12-31 23:59&quot;) ## [1] &quot;2017-12-31 23:59:00 GMT&quot; as.POSIXlt(&quot;2017-12-31 23:59&quot;) ## [1] &quot;2017-12-31 23:59:00 GMT&quot; Note that it’s assuming a timezone based on my device as I’ve not provided a default. It’s prudent to set the timezone in order to avoid the results of your code changing based on where the code is run or when13. as.POSIXct(&quot;2017-12-31 23:59&quot;, tz=&quot;UTC&quot;) ## [1] &quot;2017-12-31 23:59:00 UTC&quot; 5.4.2 Checking dates Unfortunately, R does not provide functions for checking whether the class of something is a datetime type wihtout extending it’s functionality. We have to use class() as a consequence. class(as.Date(&quot;2017-12-31&quot;)) ## [1] &quot;Date&quot; class(as.POSIXct(&quot;2017-12-31&quot;)) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; class(as.POSIXlt(&quot;2017-12-31&quot;)) ## [1] &quot;POSIXlt&quot; &quot;POSIXt&quot; You’ll see that the POSIX values not only returns the class we expected but “POSIXt” as well. POSIXt is an interchange format behind the scenes of dates in R. You don’t directly use it and you can ignore it from here on in. 5.4.3 Getting dates and times R has some functions for getting current datetime values14. Sys.Date() ## [1] &quot;2017-08-09&quot; Sys.time() ## [1] &quot;2017-08-09 18:21:42 BST&quot; Sys.timezone() ## [1] &quot;Europe/London&quot; 5.5 Summary There a few more datatypes out in the wild but numbers, strings, booleans, and dates are the core types you’ll encounter. There are normally as.* and is.* functions for converting to a datatype or checking if omething is a given datatype. You can use class() to uncover the datatype too. Data type Example Integer 1 Logical TRUE Numeric 1.1 String / character “Red” Factor (enumerated string) “Amber” or 2 in c(“Red”,“Amber”,“Green”) Complex i Date “2017-08-09” 5.6 R Data Types Exercises Convert TRUE to an integer What is the datatype of the value returned by Sys.time()? What is the datatype of the value returned by Sys.timezone()? Make this quote into an R string &gt; “Do you think this is a game?”, he said. “No I think Jenga’s a game”, Archer responded. If you want to guarantee a number is an integer, you can suffix the value with a L e.g. 42L. If you want to read more about this, check out the R manual↩ Numerics in R are floating point numbers - this mean every decimal gets stored usually with a large amount of extra decimal places. This can lead to some unusual results when comparing two decimal values and we’ll see an example later.↩ i is the square root of -1, which is an impossible number since any negative multiplied by itself would result in a positive. Descartes coined the term “imaginary” in reference to this number as it’s a consistent value in formulae but doesn’t exist in the real world.↩ You might recall that class(1) had the result of “numeric” - R was not by default considering 1 as an integer for the purpose of the class() function. This is a property of R’s evaluation of values and you can force it consider a value to be an integer by suffixing it with an L so class(1L) evaluates to “integer”.↩ In other programming languages this is often called an enumerated string↩ According to my unscientific twitter poll↩ Daylight savings time can catch you out↩ This is an area showing those wonderful R quirks - the Sys.* functions are inconsistently cased↩ "],
["basic-operations.html", "6 Basic operations 6.1 Maths 15 6.2 Comparison 6.3 Logic 6.4 Summary 6.5 Basic Operations Exercises", " 6 Basic operations Now that we have some datatypes, we can start learning what we can do with them. 6.1 Maths 15 In R, we have our common operators that you’re probably used to if you’ve performed calculations on computers before. Action Operator Example Subtract - 5 - 4 = 1 Add + 5 + 4 = 9 Multiply * 5 * 4 = 20 Divide / 5 / 4 = 1.25 Raise to the power ^ 5 ^ 4 = 625 R adheres to BODMAS16 so you can construct safe calculations that combine operators in reliable ways. (1 + 2^3) - 5 * (4/2) ## [1] -1 Additionally, there are some other operators worth knowing about. Action Operator Example Integer division %/% 9 %/% 4 = 2 Modulus %% 9 %% 4 = 1 Basic sequence : 1:3 = 1, 2, 3 The colon (:) is a really snazzy way of generating a sequence of numbers that step by 1. 1:5 ## [1] 1 2 3 4 5 5:1 ## [1] 5 4 3 2 1 -1:5 ## [1] -1 0 1 2 3 4 5 5:-1 ## [1] 5 4 3 2 1 0 -1 Integer division (%/%) tells you how many times the first number can be divided by the second without returning a fractional value. 1:8 ## [1] 1 2 3 4 5 6 7 8 1:8 %/% 3 ## [1] 0 0 1 1 1 2 2 2 1:8 %/% 4 ## [1] 0 0 0 1 1 1 1 2 The modulus (%%) tells you how much is left over after performing an integer division. 1:8 ## [1] 1 2 3 4 5 6 7 8 1:8 %% 3 ## [1] 1 2 0 1 2 0 1 2 1:8 %% 4 ## [1] 1 2 3 0 1 2 3 0 You’ll see percentage symbols (%) come up alot in future books For reasons1 not worth worrying about, R uses the % sign as the start of special operators – usually these are custom built, contain text, or reserved symbols. 6.2 Comparison The next important thing to know about is how to write comparisons. 6.2.1 Common operators The less thans and greater thans are symbols that are in pretty much every language for comparisons, but the test to see if two values are the same or not can often vary across languages. 2 &lt; 3 ## [1] TRUE 3 &gt; 2 ## [1] TRUE 2 &gt;= 2 ## [1] TRUE 2 &lt;= 2 ## [1] TRUE In R, you test if two values are exactly the same with == and you test if they’re different with !=. 2 == 2 ## [1] TRUE 2 != 2 ## [1] FALSE You can test if a value is present in a list of acceptable values using the %in% operator. This may seem a little trivial right now, but once we start covering more than one value at a time, it’ll start showing it’s uses for strings. 2 %in% 1:3 ## [1] TRUE 6.2.2 A gotcha Testing for equality can get a little weird with R because it uses a different way of storing numbers than we would expect. It doesn’t store numbers quite as precisely as we expect - somewhere at the very end of a large number of decimal places, the value can be rounded incorrectly. It doesn’t make a difference to most of our calculations but it will often hit when you’re comparing two decimal values. Let’s see an example. Both these calculation return what we think of as 0.2 0.5 - 0.3 ## [1] 0.2 0.6 - 0.4 ## [1] 0.2 Indeed, if we test 0.2 is the same as 0.2 we get a TRUE which matches our expectations. 0.2 == 0.2 ## [1] TRUE But, when we perform two calculations, even though they come out to the same value to us, there’s a little bit of imprecision in how they’re stored that stops from being exactly the same number. (0.6 - 0.4) == (0.5 - 0.3) ## [1] FALSE To avoid this issue, if you’re comparing decimal values that result from calculations it is better to use the all.equal() function. all.equal() adds a tolerance to the comparison which means the very subtle imprecision is ignored. The default tolerance is 1.510^{-8}, in other words the imprecision is very, very small. all.equal(0.6 - 0.4 , 0.5 - 0.3) ## [1] TRUE 6.2.3 Summary Action Operator Example Less than &lt; 5 &lt; 5 = FALSE Less than or equal to &lt;= 5 &lt;= 5 = TRUE Greater than &gt; 5 &gt; 5 = FALSE Greater than or equal to &gt;= 5 &gt;= 5 = TRUE Exactly equal == (0.5 - 0.3) == (0.3 - 0.1) is FALSE, 2 == 2 is TRUE Not equal != (0.5 - 0.3) != (0.3 - 0.1) is TRUE, 2 != 2 is FALSE Equal all.equal() all.equal(0.5 - 0.3,0.3 - 0.1) is TRUE In %in% &quot;Red&quot; %in% c(&quot;Blue&quot;,&quot;Red&quot;) is TRUE 6.3 Logic Once we can do a single check, we inevitably want to do multiple checks at the same time. To combine multiple checks, we can use logical operators. 6.3.1 Common operators The ampersand (&amp;) allows us to combine two checks to do an AND check which is “are both things true”. TRUE &amp; TRUE ## [1] TRUE TRUE &amp; FALSE ## [1] FALSE FALSE &amp; FALSE ## [1] FALSE (2 &lt; 3) &amp; (4 == 4) ## [1] TRUE (2 &lt; 3) &amp; (4 != 4) ## [1] FALSE The pipe / bar (|)17 allows us to do an OR check which is “are either of these things true”. TRUE | TRUE ## [1] TRUE TRUE | FALSE ## [1] TRUE FALSE | FALSE ## [1] FALSE (2 &lt; 3) | (4 == 4) ## [1] TRUE (2 &lt; 3) | (4 != 4) ## [1] TRUE The exclamation point (!) allows us to a perform a NOT by negating or swapping a check’s result. This allows you say things like “is this check true and that check not true”. TRUE &amp; TRUE ## [1] TRUE TRUE &amp; !FALSE ## [1] TRUE !FALSE &amp; !FALSE ## [1] TRUE (2 &lt; 3) &amp; (4 == 4) ## [1] TRUE (2 &lt; 3) &amp; !(4 != 4) ## [1] TRUE 6.3.2 Other operators Less commonly, there other logical checks you might to perform. We can do an XOR, where one and only one of two values being checked is true. xor(TRUE, FALSE) ## [1] TRUE xor(TRUE, TRUE) ## [1] FALSE xor(FALSE, FALSE) ## [1] FALSE We’ll see how this works in the next section, but when we use our logical operators it will do the comparison for every row. Sometimes we might be performing comparisons for many values but we need to to guarantee we get just one value back. We can use variants or AND and ORs called bitwise comparisons to achieve this. Use these with care as the results can be a little bit weird! TRUE &amp;&amp; TRUE ## [1] TRUE TRUE &amp;&amp; FALSE ## [1] FALSE TRUE || TRUE ## [1] TRUE TRUE || FALSE ## [1] TRUE 1:2&gt;1 ## [1] FALSE TRUE 2:3&gt;1 ## [1] TRUE TRUE 1:2&gt;1 &amp;&amp; 2:3&gt;1 ## [1] FALSE 6.3.3 Summary We can produce sophisticated checks from a few simple building blocks. This will come in very handy down the line when doing things like filtering datasets or creating new fields in your data. Action Operator Example Not ! !TRUE is FALSE And &amp; TRUE &amp; FALSE is FALSE, c(TRUE,TRUE) &amp; c(FALSE,TRUE) is FALSE, TRUE Or | TRUE | FALSE is TRUE, c(TRUE,FALSE) | c(FALSE,FALSE) is TRUE, FALSE Xor xor() xor(TRUE,FALSE) is TRUE Bitwise And &amp;&amp; c(TRUE,TRUE) &amp;&amp; c(FALSE,TRUE) is FALSE Bitwise Or || c(TRUE,FALSE) || c(FALSE,FALSE) is TRUE 6.4 Summary This basic operations section has taught how to manipulate values and consstruct comparisons. These are important building blocks in ddata analysis, and whilst we’ve been working with only a single value at a time, in the next section we’ll see how it works with more data. Action Operator Example Subtract - 5 - 4 = 1 Add + 5 + 4 = 9 Multiply * 5 * 4 = 20 Divide / 5 / 4 = 1.25 Raise to the power ^ 5 ^ 4 = 625 Less than &lt; 5 &lt; 5 = FALSE Less than or equal to &lt;= 5 &lt;= 5 = TRUE Greater than &gt; 5 &gt; 5 = FALSE Greater than or equal to &gt;= 5 &gt;= 5 = TRUE Exactly equal == (0.5 - 0.3) == (0.3 - 0.1) is FALSE, 2 == 2 is TRUE Not equal != (0.5 - 0.3) != (0.3 - 0.1) is TRUE, 2 != 2 is FALSE Equal all.equal() all.equal(0.5 - 0.3,0.3 - 0.1) is TRUE In %in% &quot;Red&quot; %in% c(&quot;Blue&quot;,&quot;Red&quot;) is TRUE Not ! !TRUE is FALSE And &amp; TRUE &amp; FALSE is FALSE, c(TRUE,TRUE) &amp; c(FALSE,TRUE) is FALSE, TRUE Or | TRUE | FALSE is TRUE, c(TRUE,FALSE) | c(FALSE,FALSE) is TRUE, FALSE Xor xor() xor(TRUE,FALSE) is TRUE Bitwise And &amp;&amp; c(TRUE,TRUE) &amp;&amp; c(FALSE,TRUE) is FALSE Bitwise Or || c(TRUE,FALSE) || c(FALSE,FALSE) is TRUE 6.5 Basic Operations Exercises What is the result of pi^2? Is pi greater than 3? Construct a statement to check if 5 is both greater than 3 and less than or equal to 6 What are the results if you check to see if a sequence of 1 to 5 is less than or equal to 3? I’m British, deal with it.↩ Brackets, Other, Division, Multiplication, Addition, Subtraction↩ Read Rbitrary for more info↩6.2 ComparisonThe next important thing to know about is how to write comparisons.6.2.1 Common operatorsThe less thans and greater thans are symbols that are in pretty much every language for comparisons, but the test to see if two values are the same or not can often vary across languages.2 &lt; 3## [1] TRUE3 &gt; 2## [1] TRUE2 &gt;= 2## [1] TRUE2 &lt;= 2## [1] TRUEIn R, you test if two values are exactly the same with == and you test if they’re different with !=.2 == 2## [1] TRUE2 != 2## [1] FALSEYou can test if a value is present in a list of acceptable values using the %in% operator. This may seem a little trivial right now, but once we start covering more than one value at a time, it’ll start showing it’s uses for strings.2 %in% 1:3## [1] TRUE6.2.2 A gotchaTesting for equality can get a little weird with R because it uses a different way of storing numbers than we would expect. It doesn’t store numbers quite as precisely as we expect - somewhere at the very end of a large number of decimal places, the value can be rounded incorrectly. It doesn’t make a difference to most of our calculations but it will often hit when you’re comparing two decimal values.Let’s see an example.Both these calculation return what we think of as 0.20.5 - 0.3## [1] 0.20.6 - 0.4## [1] 0.2Indeed, if we test 0.2 is the same as 0.2 we get a TRUE which matches our expectations.0.2 == 0.2## [1] TRUEBut, when we perform two calculations, even though they come out to the same value to us, there’s a little bit of imprecision in how they’re stored that stops from being exactly the same number.(0.6 - 0.4) == (0.5 - 0.3)## [1] FALSETo avoid this issue, if you’re comparing decimal values that result from calculations it is better to use the all.equal() function. all.equal() adds a tolerance to the comparison which means the very subtle imprecision is ignored. The default tolerance is 1.510^{-8}, in other words the imprecision is very, very small.all.equal(0.6 - 0.4 , 0.5 - 0.3)## [1] TRUE6.2.3 SummaryActionOperatorExampleLess than&lt;5 &lt; 5 = FALSELess than or equal to&lt;=5 &lt;= 5 = TRUEGreater than&gt;5 &gt; 5 = FALSEGreater than or equal to&gt;=5 &gt;= 5 = TRUEExactly equal==(0.5 - 0.3) == (0.3 - 0.1) is FALSE, 2 == 2 is TRUENot equal!=(0.5 - 0.3) != (0.3 - 0.1) is TRUE, 2 != 2 is FALSEEqualall.equal()all.equal(0.5 - 0.3,0.3 - 0.1) is TRUEIn%in%&quot;Red&quot; %in% c(&quot;Blue&quot;,&quot;Red&quot;) is TRUE6.3 LogicOnce we can do a single check, we inevitably want to do multiple checks at the same time.To combine multiple checks, we can use logical operators.6.3.1 Common operatorsThe ampersand (&amp;) allows us to combine two checks to do an AND check which is “are both things true”.TRUE &amp; TRUE## [1] TRUETRUE &amp; FALSE## [1] FALSEFALSE &amp; FALSE## [1] FALSE(2 &lt; 3) &amp; (4 == 4)## [1] TRUE(2 &lt; 3) &amp; (4 != 4)## [1] FALSEThe pipe / bar (|)17 allows us to do an OR check which is “are either of these things true”.TRUE | TRUE## [1] TRUETRUE | FALSE## [1] TRUEFALSE | FALSE## [1] FALSE(2 &lt; 3) | (4 == 4)## [1] TRUE(2 &lt; 3) | (4 != 4)## [1] TRUEThe exclamation point (!) allows us to a perform a NOT by negating or swapping a check’s result. This allows you say things like “is this check true and that check not true”.TRUE &amp; TRUE## [1] TRUETRUE &amp; !FALSE## [1] TRUE!FALSE &amp; !FALSE## [1] TRUE(2 &lt; 3) &amp; (4 == 4)## [1] TRUE(2 &lt; 3) &amp; !(4 != 4)## [1] TRUE6.3.2 Other operatorsLess commonly, there other logical checks you might to perform.We can do an XOR, where one and only one of two values being checked is true.xor(TRUE, FALSE)## [1] TRUExor(TRUE, TRUE)## [1] FALSExor(FALSE, FALSE)## [1] FALSEWe’ll see how this works in the next section, but when we use our logical operators it will do the comparison for every row. Sometimes we might be performing comparisons for many values but we need to to guarantee we get just one value back. We can use variants or AND and ORs called bitwise comparisons to achieve this. Use these with care as the results can be a little bit weird!TRUE &amp;&amp; TRUE## [1] TRUETRUE &amp;&amp; FALSE## [1] FALSETRUE || TRUE## [1] TRUETRUE || FALSE## [1] TRUE1:2&gt;1## [1] FALSE TRUE2:3&gt;1## [1] TRUE TRUE1:2&gt;1 &amp;&amp; 2:3&gt;1## [1] FALSE6.3.3 SummaryWe can produce sophisticated checks from a few simple building blocks. This will come in very handy down the line when doing things like filtering datasets or creating new fields in your data.ActionOperatorExampleNot!!TRUE is FALSEAnd&amp;TRUE &amp; FALSE is FALSE, c(TRUE,TRUE) &amp; c(FALSE,TRUE) is FALSE, TRUEOr|TRUE | FALSE is TRUE, c(TRUE,FALSE) | c(FALSE,FALSE) is TRUE, FALSEXorxor()xor(TRUE,FALSE) is TRUEBitwise And&amp;&amp;c(TRUE,TRUE) &amp;&amp; c(FALSE,TRUE) is FALSEBitwise Or||c(TRUE,FALSE) || c(FALSE,FALSE) is TRUE6.4 SummaryThis basic operations section has taught how to manipulate values and consstruct comparisons. These are important building blocks in ddata analysis, and whilst we’ve been working with only a single value at a time, in the next section we’ll see how it works with more data.ActionOperatorExampleSubtract-5 - 4 = 1Add+5 + 4 = 9Multiply*5 * 4 = 20Divide/5 / 4 = 1.25Raise to the power^5 ^ 4 = 625Less than&lt;5 &lt; 5 = FALSELess than or equal to&lt;=5 &lt;= 5 = TRUEGreater than&gt;5 &gt; 5 = FALSEGreater than or equal to&gt;=5 &gt;= 5 = TRUEExactly equal==(0.5 - 0.3) == (0.3 - 0.1) is FALSE, 2 == 2 is TRUENot equal!=(0.5 - 0.3) != (0.3 - 0.1) is TRUE, 2 != 2 is FALSEEqualall.equal()all.equal(0.5 - 0.3,0.3 - 0.1) is TRUEIn%in%&quot;Red&quot; %in% c(&quot;Blue&quot;,&quot;Red&quot;) is TRUENot!!TRUE is FALSEAnd&amp;TRUE &amp; FALSE is FALSE, c(TRUE,TRUE) &amp; c(FALSE,TRUE) is FALSE, TRUEOr|TRUE | FALSE is TRUE, c(TRUE,FALSE) | c(FALSE,FALSE) is TRUE, FALSEXorxor()xor(TRUE,FALSE) is TRUEBitwise And&amp;&amp;c(TRUE,TRUE) &amp;&amp; c(FALSE,TRUE) is FALSEBitwise Or||c(TRUE,FALSE) || c(FALSE,FALSE) is TRUE6.5 Basic Operations ExercisesWhat is the result of pi^2?Is pi greater than 3?Construct a statement to check if 5 is both greater than 3 and less than or equal to 6What are the results if you check to see if a sequence of 1 to 5 is less than or equal to 3?7 R objects7.1 Other key syntaxActionOperatorExampleCreate / update a variable&lt;-a &lt;- 10Create / update a variable=a = 10Create / update a variable-&gt;10 -&gt; aComment## This is my commentHelp??data.tableIdentifier``1`&lt;-27.2 In-memoryAll variables / objects will get stored in-memory;You need memory for operations too.FunctionPurposels()List what’s in-memoryrm()Remove things from memory7.3 VectorsA 1D object containing a single type of dataFunctionPurposec()Combine values into a vector:Generate a sequence1:3## [1] 1 2 3c(&quot;red&quot;,&quot;blue&quot;,&quot;orange&quot;)## [1] &quot;red&quot; &quot;blue&quot; &quot;orange&quot;7.3.1 ExercisesSee what’s in the variable LETTERS;Write a check to see if “a” is present in LETTERS;Find out which values in the sequence 1 to 10 are greater than or equal to 3 and less than 7.Make a vector containing the numbers 1 to 50;Make a vector containing two words;What happens when you combine these two vectors?7.4 Data.framesA 2D object containing multiple classes of dataFunctionPurposedata.frame()Construct a data.framedata.frame(a=1:2,b=c(&quot;blue&quot;,&quot;red&quot;))## a b## 1 1 blue## 2 2 red7.4.1 ExercisesMake a data.frame the two vectors you created in the vectors section;What happened to your text vector?7.5 ListsAn object containing multiple types of objectsFunctionPurposelist()Construct a listlist(a=1:2, b=c(&quot;blue&quot;,&quot;red&quot;), df=data.frame(a=1:2,b=c(&quot;blue&quot;,&quot;red&quot;)))## $a## [1] 1 2## ## $b## [1] &quot;blue&quot; &quot;red&quot; ## ## $df## a b## 1 1 blue## 2 2 red7.5.1 ExercisesMake a list containing some of the variables you’ve created so far.7.6 OthersMatrix A 2D object of one data typeArray A nD object of one data type8 R data manipulation basics8.1 Grid referencesR works in a grid reference system like [row , column]. So…For a 1D vector, there’s just one position i.e. vector[ row ]For a data.frame, there’s two positions i.e. data.frame[ row , column ]8.2 Grid referencesValid values include:Positive values or ranges;Negative values or ranges;Boolean ranges;Names or vectors of names.8.3 Grid referencing8.4 Grid referencing vectorsLETTERS[1]## [1] &quot;A&quot;LETTERS[1:3]## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot;LETTERS[-1]## [1] &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot;## [18] &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot;LETTERS[-13:-1]## [1] &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot;LETTERS[c(TRUE,FALSE)]## [1] &quot;A&quot; &quot;C&quot; &quot;E&quot; &quot;G&quot; &quot;I&quot; &quot;K&quot; &quot;M&quot; &quot;O&quot; &quot;Q&quot; &quot;S&quot; &quot;U&quot; &quot;W&quot; &quot;Y&quot;8.5 Grid referencing data.framesmyDF&lt;-data.frame(a=1:3, b=2:4, c=3:5)myDF[1,]## a b c## 1 1 2 3myDF[,-1]## b c## 1 2 3## 2 3 4## 3 4 5myDF[1,1]## [1] 1myDF[1:2,]## a b c## 1 1 2 3## 2 2 3 4myDF[c(TRUE,FALSE,TRUE),]## a b c## 1 1 2 3## 3 3 4 5myDF[,&quot;a&quot;]## [1] 1 2 38.5.1 ExercisesSelect all letters before “x”;Select the first 5 rows from the built-in data.frame iris;Select the first 2 columns from iris;Select the column Sepal.Length from iris by name.8.6 Name-checkingRow names can be used to extract values.myNamedVec&lt;-c(&quot;red&quot;=&quot;RED&quot;,&quot;blue&quot;=&quot;BLUE&quot;)myNamedVec[&quot;red&quot;]## red ## &quot;RED&quot;Column names can also be referenced.colnames( iris[,&quot;Species&quot;] )## NULLcolnames( iris$Species )## NULLcolnames( iris[,c(&quot;Sepal.Width&quot;,&quot;Species&quot;)] )## [1] &quot;Sepal.Width&quot; &quot;Species&quot;8.7 Self-referencingUseful for creating booleans, you can create a vector and use this inside your grid reference system.LETTERS[LETTERS&lt;&quot;T&quot;]## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot;## [18] &quot;R&quot; &quot;S&quot;myDF[myDF$a&lt;=2,]## a b c## 1 1 2 3## 2 2 3 48.7.1 ExercisesGet all letters that occur after “g”;Select rows from the iris data.frame where the Sepal.Length is greater than 5.8cm;Select rows from the iris data.frame where the Sepal.Width is below the average for that column.8.8 UpdatingYou can update part or all of simple objects by assigning new values against a grid-reference.myVec&lt;-LETTERS[1:3]myVec[1]&lt;-&quot;Z&quot;myVec## [1] &quot;Z&quot; &quot;B&quot; &quot;C&quot;myDF[1, ]&lt;- 1:3myDF## a b c## 1 1 2 3## 2 2 3 4## 3 3 4 58.9 DeletingYou can use the selections to remove valuesmyVec&lt;-myVec[-2]myVec## [1] &quot;Z&quot; &quot;C&quot;myDF&lt;-myDF[-3,-1]myDF## b c## 1 2 3## 2 3 48.9.1 ExercisesSelect everything from iris except the Species column;Create a copy of the iris data that just contains the first 100 rows and call it myIris;Update the species column to the value “Unknown” in myIris;Delete rows from myIris where the sepal length is greater than 5.5.9 R functions9.1 Using a functionA function does some computation on an object. The use of a function consists of:A function’s name;Parentheses;0 or more inputs.Sys.Date()## [1] &quot;2017-08-09&quot;sum(1:3)## [1] 69.2 Function argumentsFunctions can have:0 arguments e.g. Sys.Date();all mandatory arguments e.g. length();optional arguments e.g. sum();arguments used out of position by using their names e.g. `rnorm(mean=1, n=10).9.3 Common functionsAreaFunctionsMetadataclass, mode,length, names, nrow, ncolMeasuresmean, median, mode, range, sum, cumsumStringsgrep, gsub, substr, trim, toupper, pasteFileslist.dirs, list.files, file.exists9.4 Finding functionsFind functions by:Using code-completionUsing help-pagesUsing ?meanUsing ??meanUsing apropos(&quot;mean&quot;)9.5 Seeing how functions workYou can examine how many functions work by just typing their name without any parentheses.Sys.Date## function () ## as.Date(as.POSIXlt(Sys.time()))## &lt;bytecode: 0x000000001af284f8&gt;## &lt;environment: namespace:base&gt;9.6 ExercisesFind a function that involves Normal distributions;Find some functions operate on files.10 R packages10.1 What is a package?An R package is a bundle of functions and/or datasets. It extends the capabilities that the “base” and “recommended” R packages have. This gives us the ability to do a lot more.10.2 Using packagesInstall a package with install.packages();Load a package with library();See what’s in a package / reference it without loading packagename::function();See what’s ina package but not exposed to the public packagename:::function().10.3 Useful packagesAreaPackagesData manipulationdplyr, data.table,tidyr, stringr, forcatsData visualisationggplot2,leaflet,ggraphStatisticstidytext, caret, broomI/ORODBC, DBI, data.table, readxlWebrvest, httr, urltoolsOutputsrmarkdown, revealjs, shiny, flexdashboards10.4 Finding packages10.5 Package documentationPackages should have documentation at the following levels:Function;Workflow via vignettes;NEWS;DESCRIPTION;READMEs on github.10.6 ExercisesLoad the library dplyr;Browse dplyr’s help pages;Read a dplyr introductory vignette;Read dplyr’s README.A AnswersA.1 R Data Types ExercisesConvert TRUE to an integeras.integer(TRUE)## [1] 1What is the datatype of the value returned by Sys.time()?class(Sys.time())## [1] &quot;POSIXct&quot; &quot;POSIXt&quot;What is the datatype of the value returned by Sys.timezone()?class(Sys.timezone())## [1] &quot;character&quot;Make this quote into an R string &gt; “Do you think this is a game?”, he said. “No I think Jenga’s a game”, Archer responded.&#39;&quot;Do you think this is a game?&quot;, he said. &quot;No I think Jenga\\&#39;s a game&quot;, Archer responded.&#39;## [1] &quot;\\&quot;Do you think this is a game?\\&quot;, he said. \\&quot;No I think Jenga&#39;s a game\\&quot;, Archer responded.&quot;A.2 Basic Operations ExercisesWhat is the result of pi^2?pi^2## [1] 9.869604Is pi greater than 3?pi&gt;3## [1] TRUEConstruct a statement to check if 5 is both greater than 3 and less than or equal to 6(5 &gt; 3) &amp; (5 &lt;= 6)## [1] TRUEWhat are the results if you check to see if a sequence of 1 to 5 is less than or equal to 3?1:5 &lt;=3## [1] TRUE TRUE TRUE FALSE FALSEB SoftwareB.1 RB.2 RStudioB.3 Suggested packagesThe following are used in example content. You do not need these to work through the exercises.tidyversecaretdatasauRusinstall.packages(c(&quot;tidyverse&quot;,&quot;caret&quot;,&quot;datasauRus&quot;))If you’d like to find out about the assignment operators’ history (&lt;- and -&gt;) and many of the other quirks of R, the article Rbitrary is fantastic and highly irreverent reading.↩ This is is Shift+\\ for me. It can vary substantially on keyboard layouts, so apologies if it takes you a while to hunt this symbol down.↩ "],
["r-objects.html", "7 R objects 7.1 Other key syntax 7.2 In-memory 7.3 Vectors 7.4 Data.frames 7.5 Lists 7.6 Others", " 7 R objects 7.1 Other key syntax Action Operator Example Create / update a variable &lt;- a &lt;- 10 Create / update a variable = a = 10 Create / update a variable -&gt; 10 -&gt; a Comment # # This is my comment Help ? ?data.table Identifier ` `1`&lt;-2 7.2 In-memory All variables / objects will get stored in-memory; You need memory for operations too. Function Purpose ls() List what’s in-memory rm() Remove things from memory 7.3 Vectors A 1D object containing a single type of data Function Purpose c() Combine values into a vector : Generate a sequence 1:3 ## [1] 1 2 3 c(&quot;red&quot;,&quot;blue&quot;,&quot;orange&quot;) ## [1] &quot;red&quot; &quot;blue&quot; &quot;orange&quot; 7.3.1 Exercises See what’s in the variable LETTERS; Write a check to see if “a” is present in LETTERS; Find out which values in the sequence 1 to 10 are greater than or equal to 3 and less than 7. Make a vector containing the numbers 1 to 50; Make a vector containing two words; What happens when you combine these two vectors? 7.4 Data.frames A 2D object containing multiple classes of data Function Purpose data.frame() Construct a data.frame data.frame(a=1:2,b=c(&quot;blue&quot;,&quot;red&quot;)) ## a b ## 1 1 blue ## 2 2 red 7.4.1 Exercises Make a data.frame the two vectors you created in the vectors section; What happened to your text vector? 7.5 Lists An object containing multiple types of objects Function Purpose list() Construct a list list(a=1:2, b=c(&quot;blue&quot;,&quot;red&quot;), df=data.frame(a=1:2,b=c(&quot;blue&quot;,&quot;red&quot;))) ## $a ## [1] 1 2 ## ## $b ## [1] &quot;blue&quot; &quot;red&quot; ## ## $df ## a b ## 1 1 blue ## 2 2 red 7.5.1 Exercises Make a list containing some of the variables you’ve created so far. 7.6 Others Matrix A 2D object of one data type Array A nD object of one data type "],
["r-data-manipulation-basics.html", "8 R data manipulation basics 8.1 Grid references 8.2 Grid references 8.3 Grid referencing 8.4 Grid referencing vectors 8.5 Grid referencing data.frames 8.6 Name-checking 8.7 Self-referencing 8.8 Updating 8.9 Deleting", " 8 R data manipulation basics 8.1 Grid references R works in a grid reference system like [row , column]. So… For a 1D vector, there’s just one position i.e. vector[ row ] For a data.frame, there’s two positions i.e. data.frame[ row , column ] 8.2 Grid references Valid values include: Positive values or ranges; Negative values or ranges; Boolean ranges; Names or vectors of names. 8.3 Grid referencing 8.4 Grid referencing vectors LETTERS[1] ## [1] &quot;A&quot; LETTERS[1:3] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; LETTERS[-1] ## [1] &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; ## [18] &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; LETTERS[-13:-1] ## [1] &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; LETTERS[c(TRUE,FALSE)] ## [1] &quot;A&quot; &quot;C&quot; &quot;E&quot; &quot;G&quot; &quot;I&quot; &quot;K&quot; &quot;M&quot; &quot;O&quot; &quot;Q&quot; &quot;S&quot; &quot;U&quot; &quot;W&quot; &quot;Y&quot; 8.5 Grid referencing data.frames myDF&lt;-data.frame(a=1:3, b=2:4, c=3:5) myDF[1,] ## a b c ## 1 1 2 3 myDF[,-1] ## b c ## 1 2 3 ## 2 3 4 ## 3 4 5 myDF[1,1] ## [1] 1 myDF[1:2,] ## a b c ## 1 1 2 3 ## 2 2 3 4 myDF[c(TRUE,FALSE,TRUE),] ## a b c ## 1 1 2 3 ## 3 3 4 5 myDF[,&quot;a&quot;] ## [1] 1 2 3 8.5.1 Exercises Select all letters before “x”; Select the first 5 rows from the built-in data.frame iris; Select the first 2 columns from iris; Select the column Sepal.Length from iris by name. 8.6 Name-checking Row names can be used to extract values. myNamedVec&lt;-c(&quot;red&quot;=&quot;RED&quot;,&quot;blue&quot;=&quot;BLUE&quot;) myNamedVec[&quot;red&quot;] ## red ## &quot;RED&quot; Column names can also be referenced. colnames( iris[,&quot;Species&quot;] ) ## NULL colnames( iris$Species ) ## NULL colnames( iris[,c(&quot;Sepal.Width&quot;,&quot;Species&quot;)] ) ## [1] &quot;Sepal.Width&quot; &quot;Species&quot; 8.7 Self-referencing Useful for creating booleans, you can create a vector and use this inside your grid reference system. LETTERS[LETTERS&lt;&quot;T&quot;] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; ## [18] &quot;R&quot; &quot;S&quot; myDF[myDF$a&lt;=2,] ## a b c ## 1 1 2 3 ## 2 2 3 4 8.7.1 Exercises Get all letters that occur after “g”; Select rows from the iris data.frame where the Sepal.Length is greater than 5.8cm; Select rows from the iris data.frame where the Sepal.Width is below the average for that column. 8.8 Updating You can update part or all of simple objects by assigning new values against a grid-reference. myVec&lt;-LETTERS[1:3] myVec[1]&lt;-&quot;Z&quot; myVec ## [1] &quot;Z&quot; &quot;B&quot; &quot;C&quot; myDF[1, ]&lt;- 1:3 myDF ## a b c ## 1 1 2 3 ## 2 2 3 4 ## 3 3 4 5 8.9 Deleting You can use the selections to remove values myVec&lt;-myVec[-2] myVec ## [1] &quot;Z&quot; &quot;C&quot; myDF&lt;-myDF[-3,-1] myDF ## b c ## 1 2 3 ## 2 3 4 8.9.1 Exercises Select everything from iris except the Species column; Create a copy of the iris data that just contains the first 100 rows and call it myIris; Update the species column to the value “Unknown” in myIris; Delete rows from myIris where the sepal length is greater than 5.5. "],
["r-functions.html", "9 R functions 9.1 Using a function 9.2 Function arguments 9.3 Common functions 9.4 Finding functions 9.5 Seeing how functions work 9.6 Exercises", " 9 R functions 9.1 Using a function A function does some computation on an object. The use of a function consists of: A function’s name; Parentheses; 0 or more inputs. Sys.Date() ## [1] &quot;2017-08-09&quot; sum(1:3) ## [1] 6 9.2 Function arguments Functions can have: 0 arguments e.g. Sys.Date(); all mandatory arguments e.g. length(); optional arguments e.g. sum(); arguments used out of position by using their names e.g. `rnorm(mean=1, n=10). 9.3 Common functions Area Functions Metadata class, mode,length, names, nrow, ncol Measures mean, median, mode, range, sum, cumsum Strings grep, gsub, substr, trim, toupper, paste Files list.dirs, list.files, file.exists 9.4 Finding functions Find functions by: Using code-completion Using help-pages Using ?mean Using ??mean Using apropos(&quot;mean&quot;) 9.5 Seeing how functions work You can examine how many functions work by just typing their name without any parentheses. Sys.Date ## function () ## as.Date(as.POSIXlt(Sys.time())) ## &lt;bytecode: 0x000000001af284f8&gt; ## &lt;environment: namespace:base&gt; 9.6 Exercises Find a function that involves Normal distributions; Find some functions operate on files. "],
["r-packages.html", "10 R packages 10.1 What is a package? 10.2 Using packages 10.3 Useful packages 10.4 Finding packages 10.5 Package documentation 10.6 Exercises", " 10 R packages 10.1 What is a package? An R package is a bundle of functions and/or datasets. It extends the capabilities that the “base” and “recommended” R packages have. This gives us the ability to do a lot more. 10.2 Using packages Install a package with install.packages(); Load a package with library(); See what’s in a package / reference it without loading packagename::function(); See what’s ina package but not exposed to the public packagename:::function(). 10.3 Useful packages Area Packages Data manipulation dplyr, data.table,tidyr, stringr, forcats Data visualisation ggplot2,leaflet,ggraph Statistics tidytext, caret, broom I/O RODBC, DBI, data.table, readxl Web rvest, httr, urltools Outputs rmarkdown, revealjs, shiny, flexdashboards 10.4 Finding packages 10.5 Package documentation Packages should have documentation at the following levels: Function; Workflow via vignettes; NEWS; DESCRIPTION; READMEs on github. 10.6 Exercises Load the library dplyr; Browse dplyr’s help pages; Read a dplyr introductory vignette; Read dplyr’s README. "],
["answers.html", "A Answers A.1 R Data Types Exercises A.2 Basic Operations Exercises", " A Answers A.1 R Data Types Exercises Convert TRUE to an integer as.integer(TRUE) ## [1] 1 What is the datatype of the value returned by Sys.time()? class(Sys.time()) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; What is the datatype of the value returned by Sys.timezone()? class(Sys.timezone()) ## [1] &quot;character&quot; Make this quote into an R string &gt; “Do you think this is a game?”, he said. “No I think Jenga’s a game”, Archer responded. &#39;&quot;Do you think this is a game?&quot;, he said. &quot;No I think Jenga\\&#39;s a game&quot;, Archer responded.&#39; ## [1] &quot;\\&quot;Do you think this is a game?\\&quot;, he said. \\&quot;No I think Jenga&#39;s a game\\&quot;, Archer responded.&quot; A.2 Basic Operations Exercises What is the result of pi^2? pi^2 ## [1] 9.869604 Is pi greater than 3? pi&gt;3 ## [1] TRUE Construct a statement to check if 5 is both greater than 3 and less than or equal to 6 (5 &gt; 3) &amp; (5 &lt;= 6) ## [1] TRUE What are the results if you check to see if a sequence of 1 to 5 is less than or equal to 3? 1:5 &lt;=3 ## [1] TRUE TRUE TRUE FALSE FALSE "],
["software.html", "B Software B.1 R B.2 RStudio B.3 Suggested packages", " B Software B.1 R B.2 RStudio B.3 Suggested packages The following are used in example content. You do not need these to work through the exercises. tidyverse caret datasauRus install.packages(c(&quot;tidyverse&quot;,&quot;caret&quot;,&quot;datasauRus&quot;)) If you’d like to find out about the assignment operators’ history (&lt;- and -&gt;) and many of the other quirks of R, the article Rbitrary is fantastic and highly irreverent reading.↩ Yes, it still exists and yes, R still relies on it for some key algorithms↩ If coding interfaces were game modes, RStudio is Easy mode, Visual Studio is Normal, R-GUI is Hard, vim is Insane, and Emacs is Legacy.↩ I’m a big fan of hotkeys!↩ This hotkey is really nifty as it’ll find the start and end of a block of code and send it all to the console to be executed.↩ Like converting tabs to spaces and the number of spaces characters it should replace with.↩ If you want to guarantee a number is an integer, you can suffix the value with a L e.g. 42L. If you want to read more about this, check out the R manual↩ Numerics in R are floating point numbers - this mean every decimal gets stored usually with a large amount of extra decimal places. This can lead to some unusual results when comparing two decimal values and we’ll see an example later.↩ i is the square root of -1, which is an impossible number since any negative multiplied by itself would result in a positive. Descartes coined the term “imaginary” in reference to this number as it’s a consistent value in formulae but doesn’t exist in the real world.↩ You might recall that class(1) had the result of “numeric” - R was not by default considering 1 as an integer for the purpose of the class() function. This is a property of R’s evaluation of values and you can force it consider a value to be an integer by suffixing it with an L so class(1L) evaluates to “integer”.↩ In other programming languages this is often called an enumerated string↩ According to my unscientific twitter poll↩ Daylight savings time can catch you out↩ This is an area showing those wonderful R quirks - the Sys.* functions are inconsistently cased↩ I’m British, deal with it.↩ Brackets, Other, Division, Multiplication, Addition, Subtraction↩ This is is Shift+\\ for me. It can vary substantially on keyboard layouts, so apologies if it takes you a while to hunt this symbol down.↩ "]
]
